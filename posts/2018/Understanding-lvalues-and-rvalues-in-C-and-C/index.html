<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="翻译,C++," />





  <link rel="alternate" href="/atom.xml" title="nettee 的 blog" type="application/atom+xml" />






<meta name="description" content="本文翻译自 Eli Bendersky’s website。 原文：Understanding lvalues and rvalues in C and C++ 翻译者：nettee  我们在 C/C++ 编程中并不会经常用到 左值 (lvalue) 和 右值 (rvalue) 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 gcc">
<meta name="keywords" content="翻译,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="理解 C&#x2F;C++ 中的左值和右值">
<meta property="og:url" content="http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/index.html">
<meta property="og:site_name" content="nettee 的 blog">
<meta property="og:description" content="本文翻译自 Eli Bendersky’s website。 原文：Understanding lvalues and rvalues in C and C++ 翻译者：nettee  我们在 C/C++ 编程中并不会经常用到 左值 (lvalue) 和 右值 (rvalue) 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 gcc">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-17T13:30:12.286Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解 C&#x2F;C++ 中的左值和右值">
<meta name="twitter:description" content="本文翻译自 Eli Bendersky’s website。 原文：Understanding lvalues and rvalues in C and C++ 翻译者：nettee  我们在 C/C++ 编程中并不会经常用到 左值 (lvalue) 和 右值 (rvalue) 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 gcc">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/"/>





  <title>理解 C/C++ 中的左值和右值 | nettee 的 blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nettee 的 blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Less is more than more.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nettee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/3953668?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nettee 的 blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">理解 C/C++ 中的左值和右值</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-16T19:58:54+00:00">
                2018-10-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文翻译自 Eli Bendersky’s website。</p>
<p>原文：<a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">Understanding lvalues and rvalues in C and C++</a></p>
<p>翻译者：<a href="http://nettee.github.io" target="_blank" rel="noopener">nettee</a></p>
<hr>
<p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值 (rvalue)</em> 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 <code>gcc</code> 编译以下代码时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo() = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.c: In function &apos;main&apos;:</span><br><span class="line">test.c:8:5: error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure>
<p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值 (lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在错误信息是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testcpp.cpp: In function &apos;int&amp; foo()&apos;:</span><br><span class="line">testcpp.cpp:5:12: error: invalid initialization of non-const reference of type &apos;int&amp;&apos; from an rvalue of type &apos;int&apos;</span><br></pre></td></tr></table></figure>
<p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，<em>左值</em> 和 <em>右值</em> 到底是什么意思呢？我这篇文章将会详细解释。</p>
<a id="more"></a>
<h1 id="简单的定义"><a href="#简单的定义" class="headerlink" title="简单的定义"></a>简单的定义</h1><p>这里我故意给出了一个 <em>左值</em> 和 <em>右值</em> 的简化版定义。文章剩下的部分还会进行详细解释。</p>
<p><em>左值 (lvalue, locator value)</em> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p><em>右值 (rvalue)</em> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span><br><span class="line">var = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>赋值操作需要左操作数是一个左值。<code>var</code> 是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 = var;       // 错误！</span><br><span class="line">(var + 1) = 4; // 错误！</span><br></pre></td></tr></table></figure>
<p>常量 <code>4</code> 和表达式 <code>var + 1</code> 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p>
<p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code> 返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到 <code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p>
<p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++ 的引用让我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int globalvar = 20;</span><br><span class="line"></span><br><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return globalvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 10;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>foo</code> 返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++ 中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符 <code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code> 中的方括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;int, float&gt; mymap;</span><br><span class="line">mymap[10] = 5.6;</span><br></pre></td></tr></table></figure>
<p>之所以能赋值给 <code>mymap[10]</code>，是因为 <code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p>
<h1 id="可修改的左值"><a href="#可修改的左值" class="headerlink" title="可修改的左值"></a>可修改的左值</h1><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C 加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 'a' 是左值</span></span><br><span class="line">a = <span class="number">10</span>;           <span class="comment">// 但不可以赋值给它！</span></span><br></pre></td></tr></table></figure>
<p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为 <em>可修改左值 (modifiable lvalues)</em> 。C99标准定义可修改左值为：</p>
<blockquote>
<p>[…] 可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 <code>struct</code> 或 <code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p>
</blockquote>
<h1 id="左值与右值间的转换"><a href="#左值与右值间的转换" class="headerlink" title="左值与右值间的转换"></a>左值与右值间的转换</h1><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符 <code>&#39;+&#39;</code> 就需要两个右值参数，并返回一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// + 需要右值，所以 a 和 b 被转换成右值</span></span><br><span class="line">               <span class="comment">// + 返回右值</span></span><br></pre></td></tr></table></figure>
<p>在例子中，<code>a</code> 和 <code>b</code> 都是左值。因此，在第三行中，它们经历了隐式的 <em>左值到右值转换</em> 。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p>
<p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p>
<p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符 <code>&#39;*&#39;</code> 需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span></span><br></pre></td></tr></table></figure>
<p>相反地，一元取地址操作符 <code>&#39;&amp;&#39;</code> 需要一个左值参数，返回一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// 错误: 一元 '&amp;' 操作符需要左值参数</span></span><br><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// 正确: var 是左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// 错误: 赋值操作的左操作数需要是左值</span></span><br></pre></td></tr></table></figure>
<p>在 C++ 中 <code>&#39;&amp;&#39;</code> 符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; sref = std::string();  // 错误: 非常量的引用 &apos;std::string&amp;&apos; 错误地使用右值 &apos;std::string` 初始化</span><br></pre></td></tr></table></figure>
<p><em>常量的</em> 左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得 C++ 中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p>
<h1 id="CV-限定的右值"><a href="#CV-限定的右值" class="headerlink" title="CV 限定的右值"></a>CV 限定的右值</h1><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的 C++11 标准草稿的第 4.1 节】，我们会发现：</p>
<blockquote>
<p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T 不是类类型【译注：类类型即 C++ 中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定 CV 的版本 (cv-unqualified version of T)。其他情况下，转换后的右值类型就是 T 本身。</p>
</blockquote>
<p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <em>CV 限定符</em> 这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++ 标准的 3.9.3 节写到：</p>
<blockquote>
<p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、 <em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV 限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p>
</blockquote>
<p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV 限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV 限定的类型，但内置类型 (如 <code>int</code>) 则没有。考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bar().foo();  <span class="comment">// calls foo</span></span><br><span class="line">    cbar().foo(); <span class="comment">// calls foo const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code> 中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是 <code>const A</code>，这和 <code>A</code> 是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code> 的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p>
<h1 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++11 的右值引用"></a>C++11 的右值引用</h1><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义 (move semantics)</em> 概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references” 可以找到很多相关的资料，几个个人认为有用的资料：<a href="http://www.artima.com/cppsource/rvalue.html" target="_blank" rel="noopener">这一篇</a>， <a href="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x" target="_blank" rel="noopener">这一篇</a>，特别是 <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p>
<p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11 改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p>
<p>假设我们要实现一个“整数的 vector”，一些相关的函数可能是这样定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intvec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="keyword">size_t</span> num = <span class="number">0</span>)</span></span></span><br><span class="line">        : m_size(num), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Intvec()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"destructor"</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">            m_data = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intvec(<span class="keyword">const</span> Intvec&amp; other)</span><br><span class="line">        : m_size(other.m_size), m_data(<span class="keyword">new</span> <span class="keyword">int</span>[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"copy constructor"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span><br><span class="line">            m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Intvec&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span><br><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span><br><span class="line">        <span class="built_in">std</span>::swap(m_data, tmp.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line">    <span class="keyword">int</span>* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor) 和拷贝赋值操作符 (copy assignment operator) 【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个 logging 函数，让我们能知道是否调用了它们。</p>
<p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">Intvec v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning lvalue...\n"</span>;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning lvalue...\n"</span>;</span><br></pre></td></tr></table></figure>
<p>运行输出的结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning lvalue...</span><br><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span><br><span class="line">[<span class="number">0x28fec8</span>] destructor</span><br><span class="line">ended assigning lvalue...</span><br></pre></td></tr></table></figure>
<p>这是正常的结果，准确展示了 <code>operator=</code> 的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning rvalue...\n"</span>;</span><br><span class="line">v2 = Intvec(<span class="number">33</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning rvalue...\n"</span>;</span><br></pre></td></tr></table></figure>
<p>虽然这里的例子中是赋值一个新创建的 vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给 <code>v2</code> （例如当一个函数返回 vector 的情况）。我们会得到这样的输入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[<span class="number">0x28ff08</span>] constructor</span><br><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span><br><span class="line">[<span class="number">0x28fec8</span>] destructor</span><br><span class="line">[<span class="number">0x28ff08</span>] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>
<p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了 <em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p>
<p>不过现在你不需要多一个临时对象了。C++11 引入了右值引用，让我们可以实现“移动语义” (move semantics)，特别是可以实现“移动赋值操作符” (move assignment operator) 【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copy assignment operator)。在 C++11 中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code> 加上另一个 <code>operator=</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符号 <code>&amp;&amp;</code> 代表了新的 <em>右值引用 (rvalue reference)</em> 。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[<span class="number">0x28ff08</span>] constructor</span><br><span class="line">[<span class="number">0x28fef8</span>] move assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28ff08</span>] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>
<p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然 <code>Intvec(33)</code> 仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p>
<p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个 C++ 中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>即使不考虑左值和右值的问题，你也可以写很多 C++ 代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些 C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p>
<p>另外，在新的 C++ 规范中，因为 C++11 引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/翻译/" rel="tag"># 翻译</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2018/Getting-Started-with-JLine/" rel="next" title="Java 命令行交互输入库 JLine 入门">
                <i class="fa fa-chevron-left"></i> Java 命令行交互输入库 JLine 入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/2018/What-happens-when-return-an-object-by-value-in-Cpp/" rel="prev" title="C++ 函数可以直接返回一个对象吗？">
                C++ 函数可以直接返回一个对象吗？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars2.githubusercontent.com/u/3953668?s=460&v=4"
                alt="nettee" />
            
              <p class="site-author-name" itemprop="name">nettee</p>
              <p class="site-description motion-element" itemprop="description">持续学习中...</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/nettee" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:nettee.liu@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/5c68d1196fb9a04a0164de03" target="_blank" title="掘金">
                    
                      <i class="fa fa-fw fa-globe"></i>掘金</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/nettee" target="_blank" title="知乎">
                    
                      <i class="fa fa-fw fa-globe"></i>知乎</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简单的定义"><span class="nav-number">1.</span> <span class="nav-text">简单的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#举例"><span class="nav-number">2.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可修改的左值"><span class="nav-number">3.</span> <span class="nav-text">可修改的左值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#左值与右值间的转换"><span class="nav-number">4.</span> <span class="nav-text">左值与右值间的转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CV-限定的右值"><span class="nav-number">5.</span> <span class="nav-text">CV 限定的右值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11-的右值引用"><span class="nav-number">6.</span> <span class="nav-text">C++11 的右值引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nettee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://nettee.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/';
          this.page.identifier = 'posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/';
          this.page.title = '理解 C/C++ 中的左值和右值';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://nettee.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
