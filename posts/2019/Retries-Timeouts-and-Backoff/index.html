<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="翻译,分布式系统," />





  <link rel="alternate" href="/atom.xml" title="nettee 的 blog" type="application/atom+xml" />






<meta name="description" content="这是我在掘金翻译计划中的译文。 译文链接：[译] 分布式系统如何从故障中恢复？— 重试、超时和退避   原文地址：Retries, Timeouts and Backoff 原文作者：namc 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md 译者：">
<meta name="keywords" content="翻译,分布式系统">
<meta property="og:type" content="article">
<meta property="og:title" content="[译] 重试、超时和退避">
<meta property="og:url" content="http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/index.html">
<meta property="og:site_name" content="nettee 的 blog">
<meta property="og:description" content="这是我在掘金翻译计划中的译文。 译文链接：[译] 分布式系统如何从故障中恢复？— 重试、超时和退避   原文地址：Retries, Timeouts and Backoff 原文作者：namc 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md 译者：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-17T13:30:12.278Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[译] 重试、超时和退避">
<meta name="twitter:description" content="这是我在掘金翻译计划中的译文。 译文链接：[译] 分布式系统如何从故障中恢复？— 重试、超时和退避   原文地址：Retries, Timeouts and Backoff 原文作者：namc 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md 译者：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/"/>





  <title>[译] 重试、超时和退避 | nettee 的 blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nettee 的 blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Less is more than more.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nettee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/3953668?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nettee 的 blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[译] 重试、超时和退避</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T13:52:39+00:00">
                2019-07-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/2019/Retries-Timeouts-and-Backoff/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="posts/2019/Retries-Timeouts-and-Backoff/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这是我在<strong>掘金翻译计划</strong>中的译文。 译文链接：<a href="https://juejin.im/post/5ccf98ace51d456e6d133541" target="_blank" rel="noopener">[译] 分布式系统如何从故障中恢复？— 重试、超时和退避</a></p>
<blockquote>
<ul>
<li>原文地址：<a href="https://namc.in/2019-04-15-retries-timeouts-backoff" target="_blank" rel="noopener">Retries, Timeouts and Backoff</a></li>
<li>原文作者：<a href="http://namc.in/" target="_blank" rel="noopener">namc</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md</a></li>
<li>译者：<a href="https://github.com/nettee" target="_blank" rel="noopener">nettee</a></li>
<li>校对者：<a href="https://github.com/fireairforce" target="_blank" rel="noopener">fireairforce</a></li>
</ul>
</blockquote>
<hr>
<p>分布式系统很难。即使我们学了很多构建高可用性系统的方法，也常常会忽略系统设计中的弹性（resiliency）。</p>
<p>我们肯定听说过容错性，但什么是“弹性”呢？个人而言，我喜欢将其定义为系统处理意外情况并最终从中恢复的能力。有很多方法使你的系统能从故障中回弹，但在这篇文章中，我们主要关注以下几点：</p>
<ul>
<li><a href="#超时">超时</a></li>
<li><a href="#重试">重试</a></li>
<li><a href="#退避">退避</a></li>
<li><a href="#分布式系统中的幂等性">分布式系统中的幂等性</a></li>
</ul>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>简单来说，超时就是两个连续的数据包之间的最大不活动时间。</p>
<p>假设我们在某个时刻已经使用过了数据库驱动和 HTTP 客户端。所有帮助你的服务连接到一个外部服务器的客户端或驱动都有 Timeout 参数。这个参数通常默认为零或 -1，表示超时时间未定义，或是无限时间。</p>
<p>例如：参考 <code>connectTimeout</code> 和 <code>socketTimeout</code> 的定义 <a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">Mysql Connector 配置</a></p>
<p>大多数对外部服务器的请求都附有一个超时时间。当外部服务器没有及时响应时，超时的设置非常有必要。如果没有设置超时，并使用默认值 0/-1，你的程序可能会阻塞几分钟或更长的时间。这是因为，当你没有收到来自应用服务器的响应，并且你的超时时间无限或非常大时，这个连接会一直开着。随着有更多的请求到来，更多的连接会打开，并永远无法关闭。这会导致你的连接池耗尽，进而导致你的应用的故障。</p>
<a id="more"></a>
<p>那么，每当你使用这样的连接器来配置你的应用时，请务必在配置中设置显式的超时值。</p>
<p>超时必须在前端和后端中都实现。如果一个读/写操作在一个 REST API 或 socket 接口上阻塞了太长时间，它应当抛出异常，并且断开连接。这可以通知后端取消操作并关闭连接，从而防止连接始终打开。</p>
<h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>我们可能需要了解<strong>瞬时故障</strong>这个术语，因为我们后面会频繁用到它。简单地说，服务中的瞬时故障是一种暂时的失灵，例如网络拥塞，数据库过载，是一种在有足够的冷却周期之后也许能自己恢复的故障。</p>
<p><strong>如何判断一个故障是否是瞬时的？</strong></p>
<p>答案取决于你的 API/Server 响应的实现细节。如果你有一个 REST API，请返回 <a href="https://tools.ietf.org/html/rfc7231#section-6.6.1" target="_blank" rel="noopener">503 Service Unavailable</a>，而不是其他 5xx/4xx 错误码。这可以让客户端知道超时是由“临时的过载”引起的，而不是由于代码层面的错误。</p>
<p>重试虽然有用，但如果没有正确地配置，则会让人讨厌。下面阐述了如何找出正确的重试方法。</p>
<p><strong>重试</strong></p>
<p>如果从服务器收到的错误是瞬时的，例如网络数据包在传输时损坏，应用程序可以立即重试请求，因为故障不太可能再次发生。</p>
<p>然而，这种方法非常激进。如果你的服务已经满负荷运行，或是已经完全不可用，这种方法可能对你的服务有害。这种方法还会拖慢应用的响应时间，因为你的服务会尝试不断执行一个失败的操作。</p>
<p>如果你的业务逻辑需要这样的重试策略，你最好限制重试的次数，不向同一个源头发送过多的请求。</p>
<p><strong>带延迟的重试</strong></p>
<p>如果是连接失败或网络上的过大流量导致的故障，应用程序则应当根据业务逻辑，在重试请求之前添加延迟时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    Thread.Sleep(50); // 延迟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用一个连接至外部服务的库时，请检查它是否实现了重试策略，允许你配置重试的最大次数、重试之间的延迟等。</p>
<p>你还可以通过设置 <a href="https://tools.ietf.org/html/rfc7231#section-7.1.3" target="_blank" rel="noopener">Retry-After</a> 响应头，在服务器端实现重试的策略。</p>
<p>用日志记录操作失败的原因也很重要。有时候操作失败是因为缺少资源，这可以通过添加更多的服务实例来解决。也有时候操作失败可能是因为内存泄漏或空指针异常。那么，添加日志跟踪你的应用程序的行为就很重要了。</p>
<h2 id="退避"><a href="#退避" class="headerlink" title="退避"></a>退避</h2><p>如上所述，我们可以向重试策略中添加延迟。这种延迟通常称为<strong>线性退避</strong>。这可能不是实现一个重试策略的最佳方法。</p>
<p>考虑这种情况：你的服务因为数据库的过载发生了故障。我们的请求很可能在几次重试之后会成功。但不断发送的请求也可能<strong>加重</strong>你的数据库服务器的过载问题。因此，数据库服务会在过载状态停留更长时间，也会需要更多的时间从过载状态中恢复。</p>
<p>有几种策略可以用于解决这个问题。</p>
<p><strong>1. <a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数退避</a></strong></p>
<p>顾名思义，指数退避不是在重试之间进行周期性的延迟（例如 5 秒），而是指数性地增加延迟时间。重试会一直进行到最大次数限制。如果请求始终失败，就告诉客户端请求失败了。</p>
<p>你还必须设置最大延迟时间的限制。指数退避可能导致出现非常大的延迟时间，导致请求的 socket 保持无限期开启，并使线程“永远”休眠。这会耗尽系统资源，导致连接池的更多问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int delay = 50</span><br><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(delay);</span><br><span class="line">    if (delay &lt; MAX_DELAY)      // MAX_DELAY 可能依赖于应用程序和业务逻辑</span><br><span class="line">    &#123;</span><br><span class="line">        delay *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指数退避在分布式系统中的一个主要缺点是，<strong>在同一时间开始退避的请求，也会在同一时间进行重试</strong>。这导致了请求簇的出现。那么，我们并没有减少每一轮进行竞争的客户端数量，而是引入了没有客户端竞争的时期。固定的指数退避并不能减少很多竞争，并会生成<strong>负载峰值</strong>。</p>
<p><strong>2. <a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">带抖动的退避</a></strong></p>
<p>为了处理指数退避的负载峰值问题，我们向退避策略中添加<strong>抖动</strong>。抖动是一种去相关性策略，在重试的间隔中添加随机性，从而分摊了负载，避免了出现网络请求簇。</p>
<p>抖动通常不是任何一项配置属性，需要客户端来实现。抖动所需要的只是一个可以加入随机性的函数，可以在重试之前动态地计算出等待的时间。</p>
<p>引入抖动之后，最初的一组失败的请求可能聚集在一个很小的窗口中，例如 100 ms。但是在每个重试周期之后，请求簇会摊开到越来越大的时间窗口中。当请求分摊在足够大的窗口上时，服务就很可能能够处理这些请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int delay = 50</span><br><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(delay);</span><br><span class="line">    delay *= random.randrange(0, min(MAX_DELAY, delay * 2 ** i)) // 只是生成一个简单的随机数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>长时间的瞬时故障</strong>的情况下，任何的重试可能都不是最好的方法。这种故障可能是由于连接失效，电力中断（是的，非常真实的情况）导致的。客户端最终会重试若干次，浪费了系统资源，并进一步导致了更多系统中的故障。</p>
<p>那么，我们需要一种可以确定故障是否会长期持续的机制，并实现一种应对该情况的解决方案。</p>
<p><strong>3. <a href="https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern" target="_blank" rel="noopener">断路器</a></strong></p>
<p>断路器模式在处理服务的长时间瞬时故障时非常有用。它通过确定服务的可用性，防止客户端重试注定会失败的请求。</p>
<p>断路器设计模式要求在一系列的请求中保留连接的状态。让我们看看 <a href="https://github.com/jhalterman/failsafe#circuit-breakers" target="_blank" rel="noopener">failsafe 实现的断路器</a></p>
<pre><code>CircuitBreaker breaker = new CircuitBreaker()
  .withFailureThreshold(5)
  .withSuccessThreshold(3)
  .withDelay(1, TimeUnit.MINUTES);

Failsafe.with(breaker).run(() -&gt; connect());
</code></pre><p>当一切正常运行时，没有故障，断路器保持在关闭状态。</p>
<p>当达到执行故障的阈值时，断路器跳闸并进入<strong>打开</strong>状态。这意味着，后续的所有请求会直接失败，不会经过重试的逻辑。</p>
<p>经过一段延迟之后（如上述设置的 1 分钟），断路器会进入<strong>半开</strong>状态，测试网络请求的问题是否依然存在，并决定断路器是应当关闭还是打开。如果请求成功，断路器会重置为<strong>关闭</strong>状态，否则会重新置为<strong>打开</strong>状态。</p>
<p>这有助于在长时间的故障中避免重试执行的聚集，节省系统资源。</p>
<p>虽然断路器可以用一个状态变量在本地维护。但是如果你有一个<strong>分布式系统</strong>，你可能需要一个外部存储层。在多节点的配置中，应用服务器的状态需要在多个实例之间共享。在这种场景下，你可以使用 Redis、memcached 来记录外部服务的可用性。在向外部服务发送任何请求之前，从持久存储中查询服务的状态。</p>
<h2 id="分布式系统中的幂等性"><a href="#分布式系统中的幂等性" class="headerlink" title="分布式系统中的幂等性"></a>分布式系统中的幂等性</h2><p>幂等的服务是指客户端可以重复地发起相同的请求，并得到相同的最终结果。虽然服务器会对此操作产生相同的结果，但客户端不一定作出相同的反应。</p>
<p>对于 REST API 而言，你需要记住 ——</p>
<ul>
<li><strong>POST</strong> <strong>不是</strong>幂等的 —— POST 导致在服务器上创建新资源。n 个 POST 请求会在服务器上创建 n 个新的资源。</li>
<li><strong>GET</strong>、<strong>HEAD</strong>、<strong>OPTIONS</strong> 和 <strong>TRACE</strong> 方法<strong>永远</strong>不会改变服务器上资源的状态。因此，它们总是幂等的。</li>
<li><strong>PUT</strong> 请求是幂等的。n 个 PUT 请求会覆盖相同的资源 n-1 次。</li>
<li><strong>DELETE</strong> 是幂等的，因为它一开始会返回 200（OK），而后续的调用会返回 204（No Content）或 404（Not Found）。</li>
</ul>
<p><strong>为什么关注幂等操作呢？</strong></p>
<p>在分布式系统中，有多个服务器和客户端节点。如果你从客户端向服务器 A 发送了请求，请求失败或超时了，那么你想能够简单地再次发送该请求，而不必担心先前的请求是否有任何副作用。</p>
<p>这在微服务中是极其重要的，因为有很多独立工作的组件。</p>
<p>幂等性的一些主要好处有 ——</p>
<ul>
<li><strong>最小的复杂性</strong> —— 不需要担心副作用，可以简单地重试任何请求，并得到相同的最终结果。</li>
<li><strong>易于实现</strong> —— 你不需要添加逻辑来处理你的重试机制中先前失败的请求。</li>
<li><strong>易于测试</strong> —— 每个动作都会产生相同的结果，没有意外。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们梳理了一系列构建更容错系统的方法。然而，这些方法并不是全部。最后，我想指出几个供你查看的要点，或许能帮助提高你系统的可用性和容错性。</p>
<ul>
<li>在多节点配置中，如果一个客户端重试了多次，这些请求很可能到达同一个服务器。此时，最好返回一个失败的响应，让客户端从头重试。</li>
<li>对你的系统做性能统计，让它们时刻准备最坏的情况。你可以查看 <a href="https://github.com/Netflix/chaosmonkey" target="_blank" rel="noopener">Netflix 的 Chaos Monkey</a> —— 这是一个在系统中触发随机故障的弹性测试工具。这能让你为可能发生的故障做好准备，构建一个有弹性的系统。</li>
<li>如果你的系统由于某种原因处于过载状态，你可以尝试通过减载（load shedding）来分布负载。Google 做了一个很棒的<a href="https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons" target="_blank" rel="noopener">案例研究</a>，可以作为一个很好的起点。</li>
</ul>
<hr>
<p>一些资源：</p>
<ul>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/patterns-ace.html" target="_blank" rel="noopener">分布式系统中的模式</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry" target="_blank" rel="noopener">重试模式 - Microsoft</a></li>
<li><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">Martin Fowler - 断路器</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/翻译/" rel="tag"># 翻译</a>
          
            <a href="/tags/分布式系统/" rel="tag"># 分布式系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2019/Monkey-inject-events-with-Automated-Network-Control/" rel="next" title="使用 Monkey 向 Android 设备精确发送事件">
                <i class="fa fa-chevron-left"></i> 使用 Monkey 向 Android 设备精确发送事件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/2019/How-to-write-a-simple-parser-in-hand/" rel="prev" title="如何手写一个简单的 parser">
                如何手写一个简单的 parser <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars2.githubusercontent.com/u/3953668?s=460&v=4"
                alt="nettee" />
            
              <p class="site-author-name" itemprop="name">nettee</p>
              <p class="site-description motion-element" itemprop="description">持续学习中...</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/nettee" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:nettee.liu@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/5c68d1196fb9a04a0164de03" target="_blank" title="掘金">
                    
                      <i class="fa fa-fw fa-globe"></i>掘金</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/nettee" target="_blank" title="知乎">
                    
                      <i class="fa fa-fw fa-globe"></i>知乎</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#超时"><span class="nav-number">1.</span> <span class="nav-text">超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重试"><span class="nav-number">2.</span> <span class="nav-text">重试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#退避"><span class="nav-number">3.</span> <span class="nav-text">退避</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式系统中的幂等性"><span class="nav-number">4.</span> <span class="nav-text">分布式系统中的幂等性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">5.</span> <span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nettee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://nettee.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/';
          this.page.identifier = 'posts/2019/Retries-Timeouts-and-Backoff/';
          this.page.title = '[译] 重试、超时和退避';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://nettee.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
