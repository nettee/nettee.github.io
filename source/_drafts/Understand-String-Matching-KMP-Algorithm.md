title: 理解 KMP 字符串匹配算法
date: 2018-06-29 10:51:03
tags: [Algorithm]
---

KMP 算法一直是一个很有效但又很难理解的字符串匹配算法。但如果抓住了它的基本原理，其实算法的思路还是非常清晰的。我总结了看到的几份资料，试图理解 KMP 算法的思想。

首先我们进行一些基本的定义：字符串匹配是在给定的 *文本字符串* `T` 中，找到与 *模式字符串* `P` 相符的子字符串。我们设文本字符串的长度为 `n`，模式字符串的长度为 `m`，下标从 0 开始，即 `P[0..m)` 表示整个模式字符串。

## 朴素算法

朴素算法是我们都可以立刻写出来的算法。它使用两层循环，花费 O(mn) 的时间。

```c++
int search(string pattern, string text) {
    int m = pattern.length();
    int n = text.length();
    for (int i = 0; i < n; i++) {
        bool match = true;
        for (j = 0; j < m; j++) {
            if (text[i+j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            return i;
        }
    }
    return -1;
}
```

为了对算法的本质有所理解，我们将朴素算法改写成使用 *字符指针* 的算法。其中 *文本指针* `i` 指向文本字符串中待匹配的字符，*模式指针* `j` 指向模式字符串中待匹配的字符。

```c++
int search(string pattern, string text) {
    int m = pattern.length();
    int n = text.length();
    int i = 0;
    int j = 0;
    while (i < n && j < m) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        } else {
            i = i - j + 1;
            j = 0;
        }
    }
    if (j == m) {
        return i - m;
    } else {
        return -1;
    }
}
```

在这个算法中，我们每次比较 `i` 与 `j` 所指向的字符。当两个字符相匹配时，将指针 `i` 和 `j` 同时前进一位。而当两个字符不相匹配时（称为 *失配*），将指针 `i` 和 `j` 进行回退，模式指针 `j` 回退到模式字符串的开头处，而文本指针 `i` 回退到本次匹配的开始位置的下一个字符。

可以看到，指针前进的次数就代表了算法的时间复杂度。在朴素算法中，指针最多回退 O(n) 次，每次最多回退 O(m) 位，因此最坏情况下指针需要前进 O(mn) 位。而 KMP 算法的关键特点为，不回退文本指针 `i`，这样保证指针最多前进 O(n) 次，保证了 O(n) 的最坏时间复杂度。

## 模式指针的回退

KMP 算法利用了字符串匹配中一个很重要的性质：当 `T[i]` 和 `P[j]` 出现失配时，实际上前 j 次匹配都是成功的，也就是说，`T[i-j..i) = P[0..j)`。这样，我们可以由模式字符串知道文本字符串前 j 个字符的内容，就不需要回退文本指针 `i` 来获得信息了。

我们现在知道了 `T[i-j..i)` 这 j 个字符，就是模式字符串的前 j 个字符 `P[0..j)` 。我们将模式字符串向右移动，使得模式字符串与 `T[i-j..i)` 重合的部分相匹配。如下图所示，当 j=6 时出现失配，此时 `T[i-j..i) = ababab`。我们将模式字符串向右移动两位，使得上下重合的部分相匹配 (`abab`)。再将模式指针 `j` 移动到与文本指针 `i` 对齐，就可以进行下一步的匹配了。我们相当于将模式指针回退了两位，而整个过程文本指针无需回退。

![KMP1][kmp1]

形式化地来说，当 `T[i]` 与 `P[j]` 出现失配时，下一步文本指针 `i` 不会进行回退，而模式指针 `j` 则需要回退到某个位置 k (k<j)。此时模式字符串与 `T[i-j..i)` 会有 k 个字符重合，我们希望重合的部分相等，即 `P[0..k) = T[i-k..i)`，让 `P[k]` 可以和 `T[i]` 继续匹配。当有多个 k 满足要求时，我们应当取最大的那个。由于 `P[0..j) = T[i-j..i)`，所以实际上是寻找 k，使 `P[0..k) = P[j-k..j)`，即 k 为 `P[0..j)` 的前后缀最长公共部分的长度。

## 参考资料

+ Robert Sedgewick, _Algorithms, Fourth Edition_
+ [如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎](https://www.zhihu.com/question/21923021/answer/281346746)

[kmp1]: Understand-String-Matching-KMP-Algorithm/kmp1.jpg
