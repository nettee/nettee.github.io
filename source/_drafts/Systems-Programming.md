到底什么是系统编程？
Will Crichton，2018年9月9日

前言：我对“系统编程” (systems programming) 这个词不太满意。对我而言，它实际上把两个概念混为一谈：“底层编程”（关注机器的实现细节），以及“系统设计”（创建并管理一系列复杂的交互的组件）。为什么会这样？这种情况持续了多久？重新定义“系统”这个概念，我们会得到什么启发？

# 1970 年代：汇编之上的改进

Let’s travel back to the origins of modern computer systems to understand how the term evolved. I don’t know who coined the phrase originally, but my searches suggest that serious effort in defining “computer systems” started around the early 70s. In Systems Programming Languages (Bergeron1 et al. 1972), the authors say:

> A system program is an integrated set of subprograms, together forming a whole greater than the sum of its parts, and exceeding some threshold of size and/or complexity. Typical examples are systems for multiprogramming, translating, simulating, managing information, and time sharing. […] The following is a partial set of properties, some of which are found in non-systems, not all of which need be present in a given system.
> 1. 需要解决的问题内涵广泛，由许多（而且常常是多种多样）的子问题组成。 
> 1. 系统程序可能是用于支持其他的软件和应用程序，也可能本身就是一个完整的应用程序。
> 1. 它是为持续的“产业”使用而设计，而不是针对单个应用程序问题的一次性解决方案。
> 1. 它可以持续地演化，支持不同数量和种类的特性。
> 1. 系统程序无论是模块内还是模块间（即“通信”），都需要遵循一定的规则或结构。它常常是由多人设计并实现的。

This definition is fairly agreeable—computer systems are large-scale, long-used, and time-varying. However, while this definition is largely descriptive, a key idea in the paper is prescriptive: advocating for the separation of low-level languages from systems languages (at the time, contrasting assembly with FORTRAN).

The goal of a systems programming language is to provide a language which can be used without undue concern for “bit twiddling” considerations, yet will generate code that is not appreciably worse than that generated by hand. Such a language should combine the conciseness and readability of high level languages with the space and time efficiency and the ability to “get at” machine and operating system facilities obtainable in assembler language. Designing, writing, and debugging time should be minimized without imposing unnecessary overhead on systems resources.

At the same time, researchers from CMU published BLISS: A Language for Systems Programming (Wulf et al. 1972), describing it as:

We refer to BLISS as an “implementation language”, although we admit that the term is somewhat ambiguous since, presumably, all computer languages are used to implement something. To us the phrase connotes a general purpose, higher-level language in which the primary emphasis has been placed upon a specific application, namely the writing of large, production software systems for a specific machine. Special purpose languages, such as compiler-compilers, do not fall into this category, nor do we necessarily assume that these languages need be machine-independent. We stress the word “implementation” in our definition and have not used words such as “design” and “documentation.” We do not necessarily expect that an implementation language will be an appropriate vehicle for expressing the initial design of a large system nor for the exclusive documentation of that system. Concepts such as machine independence, expressing the design and implementation in the same notation, self-documentation, and others, are clearly desirable goals and are criteria by which we evaluated various languages.

Here, the authors contrast the idea of an “implementation language” as being higher-level than assembly, but lower-level than a “design language”. This resists the definition in the preceding paper, advocating that designing a system and implementing a system should have separate languages.

Both of these papers are research artifacts or advocacies. The last entry to consider (also from 1972, a productive year!) is Systems Programming (Donovan 1972), an educational text for learning systems programming.

What is systems programming? You may visualize a computer as some sort of beast that obeys all commands. It has been said that computers are basically people made out of metal or, conversely, people are computers made out of flesh and blood. However, once we get close to computers, we see that they are basically machines that follow very specific and primitive instructions. In the early days of computers, people communicated with them by on and off switches denoting primitive instructions. Soon people wanted to give more complex instructions. For example, they wanted to be able to say X = 30 * Y; given that Y = 10, what is X? Present day computers cannot understand such language without the aid of systems programs. Systems programs (e.g. compilers, loaders, macro processors, operating systems) were developed to make computers better adapted to the needs of their users. Further, people wanted more assistance in the mechanics of preparing their programs.



I like that this definition reminds us that systems are in service of people, even if they’re just infrastructure not directly exposed to the end user.

# 1990 年代：脚本语言的兴起

In the 70s and 80s, it seems like most researchers saw systems programming usually as a contrast to assembly programming. There simply were no other good tools to build systems. (I’m not sure where Lisp was in all this? None of the resources I read cited Lisp, although I’m vaguely aware that Lisp machines existed however briefly.)

However, in the mid 90s, a major sea change occurred in programming languages with the rise of dynamically-typed scripting languages. Improving on earlier shell scripting systems like Bash, languages like Perl (1987), Tcl (1988), Python (1990), Ruby (1995), PHP (1995), and Javascript (1995) worked their way into the mainstream. This culminated in the influential article “Scripting: Higher Level Programming for the 21st Century” (Ousterhout 1998). This articulated “Ousterhout’s dichotomy” between “system programming languages” and “scripting languages.”

Scripting languages are designed for different tasks than system programming languages, and this leads to fundamental differences in the languages. System programming languages were designed for building data structures and algorithms from scratch, starting from the most primitive computer elements such as words of memory. In contrast, scripting languages are designed for gluing: they assume the existence of a set of powerful components and are intended primarily for connecting components together. System programming languages are strongly typed to help manage complexity, while scripting languages are typeless to simplify connections between components and provide rapid application development. […] Several recent trends, such as faster machines, better scripting languages, the increasing importance of graphical user interfaces and component architectures, and the growth of the Internet, have greatly increased the applicability of scripting languages.



On a technical level, Ousterhout contrasted scripting vs. systems along the axes of type-safety and instructions-per-statement, as shown above. On a design level, he characterized the new roles for each language class: systems programming is for creating components, and scripting is for gluing them together.

Around this time, statically typed but garbage collected languages also started to gain popularity. Java (1995) and C# (2000) turned into the titans we know today. While these two aren’t traditionally considered “systems programming languages,” they have been used to design many of the world’s biggest software systems. Ousterhout even explicitly mentioned “in the Internet world that is taking shape now, Java is used for system programming.”

# 2010 年代：界线开始模糊

在过去十年中，脚本语言好系统编程语言之间的界线开始变得模糊。像 Dropbox 这样的公司能够只用 Python 就构建出巨大而且可扩展的系统。Javascript 也用来在数以万计的网页中渲染实时、复杂的界面。渐进类型系统 (gradual typing) 在 [Python](http://mypy-lang.org/), [JavaScript](https://www.typescriptlang.org/) 等脚本语言中已经成为主流。开发者可以使用这种类型系统，在“原型”代码上逐步添加静态类型信息来过渡到“生产”代码。

与此同时，大量工程资源被用于开发 JIT 编译器，既包括静态语言的（如 Java 的 HotSpot），也包括动态语言的（如 Lua 的 LuaJIT，JavaScript 的 V8，Python 的 PyPy）。这些 JIT 编译器可以使语言的性能[和传统的系统编程语言（C，C++）相媲美](https://attractivechaos.github.io/plb/)。像 Spark 这样大型可扩展的分布式系统也是用 Scala 写的。而像 Julia, Swift 和 Go 这样的新语言也在不断提升垃圾回收类语言的性能上限。

这里有一个叫做 [2014 年及以后的系统编程](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond) 的座谈会，其中的几位嘉宾都是当今几个系统语言（自称）的创造者：C++ 的作者 Bjarne Stroustrup、Go 的作者 Rob Pike、D 开发者 Andrei Alexandrescu，以及 Rust 开发者 Niko Matsakis。当被问道“什么是如今的系统编程语言”时，他们回答到（整理稿）：

> + **Niko Matsakis**: 写客户端应用程序用到的语言。这和 Go 面向的领域正好相反。客户端程序需要满足延迟、安全等标准，其中很多在服务器端是不会遇到的。
> + **Bjarne Stroustrup**: 系统编程最开始是需要处理硬件的情况，不过后来应用程序变得更加复杂。你需要管理复杂性。如果你遇到了重大的资源限制，或者你需要细粒度的控制，那么你进入了系统编程的领域。编程中的限制决定了它是否是系统编程。内存够用吗？时间够用吗？
> + **Rob Pike**: 我们发布 Go 的时候将其称为系统编程语言。这个词似乎不太恰当，因为很多人以为它是写操作系统的语言。我们觉得它更应该叫做“写服务器的语言”。现在 Go 成为了云平台语言，这样系统语言又可以定义为“跑在云上的语言”。
> + **Andrei Alexandrescu**: 我有几个检验一个语言是不是系统语言的方法。系统语言必须能让你写出自己的内存分配器。系统语言应当能让你将一个整数转换为指针，因为硬件实际上就是这么工作的。

那么，系统语言意味着高性能？资源限制？硬件控制？云平台？概括说来，C, C++, Rust, D 这些语言因为对于机器的抽象层次而可以分为一类。这些语言暴露了底层硬件的细节，如内存分配/布局，以及细粒度的资源管理。

从另一个角度来看，当你遇到了效率问题，你有多大的自由度来解决它？底层编程语言的好处在于，当你发现了效率问题时，你可以通过仔细控制机器细节（如并行化指令，调整数据结构大小以保证其在缓存中，等等）来消除性能瓶颈。正如静态类型可以让你对“我要加的两个东西肯定都是整数”很有信心，底层语言可以让你对“这段代码在机器上肯定会像我指定的一样执行”很有信心。

相比之下，优化脚本语言就[相当难以捉摸](https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html)。你很难知道代码运行时是否和你期望的一致。自动并行化编译器遇到的是同样的问题——“自动并行化并不是一个编程模型”（参见 [ispc 的故事](https://pharr.org/matt/blog/2018/04/18/ispc-origins.html)）。就像在 Python 中写一个接口，你想的是 “我希望调用这个函数的人一定要传进一个整数”。

# 今天：那么到底什么是系统编程呢？

这又让我想起了一开始那个问题。我认为很多人只是把系统编程看作是底层编程——一种暴露底层机器细节的方式。那么，系统又究竟如何定义呢？回顾 1972 年的那个定义：

> 1. 需要解决的问题内涵广泛，由许多（而且常常是多种多样）的子问题组成。 
> 1. 系统程序可能是用于支持其他的软件和应用程序，也可能本身就是一个完整的应用程序。
> 1. 它是为持续的“产业”使用而设计，而不是针对单个应用程序问题的一次性解决方案。
> 1. 它可以持续地演化，支持不同数量和种类的特性。
> 1. 系统程序无论是模块内还是模块间（即“通信”），都需要遵循一定的规则或结构。它常常是由多人设计并实现的。

这几点看上去更像是软件工程的问题（模块化、重用、代码演化），而不是底层的性能问题。这意味着，任何注重于解决这些软件工程问题的编程语言，其实都可以叫做系统语言！当然，这不是说所有的语言都是系统语言——动态语言似乎仍然离系统语言很远，因为动态类型以及“请求宽恕，而不是许可”的格言（译注——Python等语言中一种“先进行处理，再解决异常”的编程风格）不利于良好的代码质量。

那么这个定义给我们带来了什么？有一个激进的观点：像 OCaml 和 Haskell 这样的函数式语言，相比 C 或 C++ 这样的底层语言，其实更加面向系统 (system-oriented)。当我们向本科生教授系统编程的时候，我们应该引入函数式编程的原则，例如不变性 (immutability) 的价值、丰富的类型系统对于提升接口设计的影响、以及高阶函数的作用。学校里应该既教授系统编程，又教授底层编程。

系统编程真的和好的软件工程是不同的吗？这不一定。但是问题在于，软件工程和底层编程通常是孤立地教授的。虽然大部分的软件工程课程是以 Java 为中心的 “书写良好的接口和测试”，但我们也应该教给学生如何设计有重大资源限制的系统。或许我们将底层编程叫做“系统编程”，是因为很多有趣的软件系统是底层的（如数据库、网络、操作系统等等）。由于底层系统有很多的限制，因此需要设计者进行创造性的思考。

另一个可以得出的结论是，底层程序员应该试图理解系统设计中的哪些想法可以应用于现代硬件上。我觉得 Rust 社区在这方面非常有创新性，寻找将好的软件设计/函数式编程的原则（如内存安全、future、错误处理）应用到底层问题的方法。

总而言之，我们所谓的“系统编程”我认为应该叫做“底层编程”。“设计计算机系统”这个重要的领域，其实应该有自己独特的名字。通过将“系统编程”和“底层编程”两个概念区分开，我们就能在程序语言设计时的概念更加清晰。这也为系统和机器间共享见解提供了可能：我们如何为机器设计系统，我们又如何为系统设计机器？
