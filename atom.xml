<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nettee 的 blog</title>
  <icon>https://www.gravatar.com/avatar/f059bf6c503b7665e83bece31598dd4b</icon>
  <subtitle>Less is more than more.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-17T13:30:12.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>nettee</name>
    <email>nettee.liu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译] 动态规划算法的实际应用：接缝裁剪</title>
    <link href="http://yoursite.com/posts/2019/real-world-dynamic-programming-seam-carving/"/>
    <id>http://yoursite.com/posts/2019/real-world-dynamic-programming-seam-carving/</id>
    <published>2019-11-17T13:52:05.000Z</published>
    <updated>2019-12-17T13:30:12.290Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在<strong>掘金翻译计划</strong>中的译文。 译文链接：<a href="https://juejin.im/post/5de8b483f265da33d039c618" target="_blank" rel="noopener">[译] 动态规划算法的实际应用：接缝裁剪</a></p><blockquote><ul><li>原文地址：<a href="https://avikdas.com/2019/05/14/real-world-dynamic-programming-seam-carving.html" target="_blank" rel="noopener">Real-world dynamic programming: seam carving</a></li><li>原文作者：<a href="https://avikdas.com/" target="_blank" rel="noopener">Avik Das</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/real-world-dynamic-programming-seam-carving.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/real-world-dynamic-programming-seam-carving.md</a></li><li>译者：<a href="https://github.com/nettee" target="_blank" rel="noopener">nettee</a></li><li>校对者：<a href="https://github.com/JalanJiang" target="_blank" rel="noopener">JalanJiang</a>，<a href="https://github.com/TokenJan" target="_blank" rel="noopener">TokenJan</a></li></ul></blockquote><hr><p>我们一直认为动态规划（dynamic programming）是一个在学校里学习的技术，并且只是用来通过软件公司的面试。实际上，这是因为大多数的开发者不会经常处理需要用到动态规划的问题。本质上，<strong>动态规划可以高效求解那些可以分解为高度重复子问题的问题</strong>，因此在很多场景下是很有用的。</p><p>在这篇文章中，我将会仔细分析动态规划的一个有趣的实际应用：接缝裁剪（seam carving）。<a href="https://dl.acm.org/citation.cfm?id=1276390" target="_blank" rel="noopener">Avidan 和 Shamir 的这篇文章 <strong>Seam Carving for Content-Aware Image Resizing</strong></a> 中详细讨论了这个问题以及提出的技术（搜索文章的标题可以免费获取）。</p><p>这篇文章是动态规划的系列文章中的一篇。如果你还不了解动态规划技术，请参阅我写的<a href="https://medium.com/future-vision/a-graphical-introduction-to-dynamic-programming-2e981fa7ca2?source=friends_link&amp;sk=37cd14642cf1a83eb0bb33d231442837" target="_blank" rel="noopener">动态规划的图形化介绍</a>。</p><h2 id="环境敏感的图片大小调整"><a href="#环境敏感的图片大小调整" class="headerlink" title="环境敏感的图片大小调整"></a>环境敏感的图片大小调整</h2><p>为了用动态规划解决实际问题，我们需要将问题建模为可以应用动态规划的形式。本节介绍了这个问题的必要的准备工作。</p><p>论文的原作者介绍了一种在智能考虑图片内容的情况下改变图片的宽度或高度的方法，叫做环境敏感的图片大小调整（content-aware image resizing）。后面会介绍论文的细节，但这里先做一个概述。假设你想调整下面这个冲浪者图片的大小。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/surfer.jpg" alt="一个冲浪者在平静的海面中间清晰可见的俯视图，右边是身后汹涌的海浪。图片来自 [Pixabay](https://pixabay.com/photos/blue-beach-surf-travel-surfer-4145659/) 上的 [Kiril Dobrev](https://pixabay.com/users/kirildobrev-12266114/)。"></p><p>论文中详细讨论了，有多种方法可以减少图片的宽度。我们最先想到的是裁剪和缩放，以及它们相关的缺点。删除图片中部的几列像素也是一种方法，但你也可以想象得到，这样会在图片中留下一条可见的分割线，左右的内容无法对齐。而且即使是这些方法全用上了，也只能删掉这么点图片：</p><a id="more"></a><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/surfer-crop-middle.jpg" alt="尝试通过裁掉图片的左侧和中间部分来减少图片宽度。裁掉中间会在图片中留下一条可见的分割线。"></p><p>Avidan 和 Shamir 在他们的论文中展示的是一个叫做<strong>接缝裁剪</strong>的技术。它首先会识别出图片中不太有意义的“低能量”区域，然后找到穿过图片的能量最低的“接缝”。对于减少图片宽度的情况，接缝裁剪会找到一个竖向的、从图片顶部延伸到底部、下一行最多向左或向右移动一个像素的接缝。</p><p>在冲浪者的图片中，能量最低的接缝穿过图片中部水面最平静的位置。这和我们的直觉相符。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/surfer-seam.jpg" alt="冲浪者图片中发现的最低能量接缝。接缝通过一条五个像素宽的红线来可视化，实际上接缝只有一个像素宽。"></p><p>通过识别出能量最低的接缝并删除它，我们可以把图片的宽度减少一个像素。不断重复这个过程可以充分减少图片的宽度。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/surfer-resized.jpg" alt="宽度减少了 1024 像素后的冲浪者图片。"></p><p>这个算法删除了图片中间的静止水面，以及图片左侧的水面，这仍然符合我们的直觉。和直接剪裁图片不同的是，左侧水面的质地得以保留，也没有突兀的过渡。图片的中间确实有一些不是很完美的过渡，但大部分的结果看起来很自然。</p><h4 id="定义图片的能量"><a href="#定义图片的能量" class="headerlink" title="定义图片的能量"></a>定义图片的能量</h4><p>这个算法的关键在于找到能量最低的接缝。要做到这一点，我们首先定义图片中每个像素的能量，然后应用动态规划算法来寻找穿过图片的能量最低的路径。下一节中会详细讨论这个算法。让我们先看看如何为图片中的像素定义能量。</p><p>论文中讨论了一些不同的能量函数，以及它们在调整图片大小时的效果。简单起见，我们使用一个简单的能量函数，表达图片中的颜色在每个像素周围的变化强烈程度。为了完整起见，我会将能量函数介绍得详细一点，以备你想自己实现它，但这部分的计算仅仅是为后续动态规划作准备。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/energy-gradient-horizontal.png" alt="左半边表示，当相邻像素的颜色非常不同时这个像素的能量大。右半边表示，当相邻像素的颜色比较相似时像素的能量小。"></p><p>为了计算单个像素的能量，我们检查这个像素左右的像素。我们计算逐个分量之间的平方距离，也就是分别计算红色、绿色、蓝色分量之间的平方距离，然后相加。我们对中心像素上下的像素进行同样的计算。最终，我们将水平和垂直距离相加。</p><p>$$<br>\begin{aligned}<br>| \Delta x |^2 &amp;= (\Delta r_x)^2 + (\Delta g_x)^2 + (\Delta b_x)^2 \newline<br>| \Delta y |^2 &amp;= (\Delta r_y)^2 + (\Delta g_y)^2 + (\Delta b_y)^2 \newline<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>e(x, y)      &amp;= | \Delta x | ^2 + | \Delta y | ^2<br>\end{aligned}<br>$$</p><p>唯一的特殊情况是当像素位于边缘，例如左侧边缘时，它的左边没有像素。对于这种情况，我们只需比较将其和右边的像素比较。对于上边缘、右边缘、下边缘的像素，会进行类似的调整。</p><p>当周围像素的颜色非常不同时，能量函数较大；而当颜色相似时，能量函数较小。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/surfer-energy.jpg" alt="冲浪者图片中每个像素的能量，用白色显示高能量像素、黑色显示低能量像素来可视化。不出所料，中间的冲浪者和右侧的湍流的能量最高。"></p><p>这个能量函数在冲浪者图片上效果很好。然而，能量函数的值域很广，当对能量进行可视化时，图片中的大部分像素看起来能量为零。实际上，这些区域的能量只是相对于能量最高的区域比较低，但并不是零。为了让能量函数更容易可视化，我放大了冲浪者，并调亮了该区域。</p><h2 id="使用动态规划搜索低能量接缝"><a href="#使用动态规划搜索低能量接缝" class="headerlink" title="使用动态规划搜索低能量接缝"></a>使用动态规划搜索低能量接缝</h2><p>为每个像素计算出了能量之后，我们现在可以搜索从图片顶部延伸到底部的低能量接缝了。同样的分析方法也适用于从左侧延伸至右侧的水平接缝，可以让我们减少原始图片的高度。不过，我们现在只关注垂直的接缝。</p><p>我们先定义最低能量接缝的概念：</p><ul><li>接缝是像素的序列，其中每行有且仅有一个像素。要求对于连续的两行，$x$ 坐标的变化最多为 1，这保证了这是一条相连的接缝。</li><li>最低能量接缝是指接缝中所有像素的能量总和最小的一条接缝。</li></ul><p>注意，最低能量接缝不一定会经过图片中的最低能量像素。是让接缝的能量总和最小，而不是让单个像素的能量最小。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/seam-finding-greedy.png" alt="贪心的方法行不通。过早选择了低能量像素后，我们陷入了图片的高能量区域，如图中红色路径所示。"></p><p>从上图中可以看到，“从最顶行开始，依次选择下一行中的最低能量像素”的贪心方法是行不通的。在选择了能量为 2 的像素之后，我们被迫走入了图片中的一个高能量区域。而如果我们在中间一行选择一个能量相对高一点的像素，我们还有可能进入左下的低能量区域。</p><h4 id="将问题分解为子问题"><a href="#将问题分解为子问题" class="headerlink" title="将问题分解为子问题"></a>将问题分解为子问题</h4><p>上述的贪心方法的问题在于，当决定如何延伸接缝时，我们没有考虑到未来的接缝剩余部分。我们无法预知未来，但我们可以记录下目前所有已知的信息，从而可以观察过去。</p><p>让我们反过来进行选择。<strong>我们不再从多个像素中选择一个来延伸单个接缝，而是从多个接缝中选择一个来连接单个像素。</strong> 我们要做的是，对于每个像素，在上一行可以连接的像素中进行选择。如果上一行中的每个像素都编码了到那个像素为止的路径，我们本质上就观察了那个像素之前的所有历史。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/seam-finding-choice.png" alt="对每个像素，我们查看上一行中的三个像素。本质的问题是，我们应当延伸哪个接缝？"></p><p>这表明了可以对图片中的每个像素划分子问题。因为子问题需要记录到那个像素的最优路径，比较好的方法是将每个像素的子问题定义为<strong>以那个像素结尾</strong>的最低能量接缝的能量。</p><p>和贪心的方法不同，上述方法本质上尝试了图片中的所有路径。只不过，当尝试所有可能的路径时，在一遍又一遍地解决相同的子问题，让动态规划成为这个方法的一个完美的选择。</p><h4 id="定义递归关系"><a href="#定义递归关系" class="headerlink" title="定义递归关系"></a>定义递归关系</h4><p>与往常一样，我们现在需要将上述的思路形式化为一个递归关系。子问题是关于原图片中的每一个像素的，因此递归关系的输入可以简单的是那个像素的 $x$ 和 $y$ 坐标。这可以使输入是简单的整数、使子问题的排序变得容易，也使我们可以用一个二维数组存储计算过的值。</p><p>我们定义函数 $M(x,y)$ 表示从图片顶部开始、到像素 $(x,y)$ 结束的最低能量的垂直接缝。使用字母 $M$ 是因为论文里就是这么定义的。</p><p>首先，我们定义基本情况（base case）。在图片的最顶行，所有以这些像素结尾的接缝都只有一个像素长，因为再往上没有其他像素了。因此，以这些像素结尾的最低能量接缝就是这些像素的能量：</p><p>$$<br>\begin{aligned}<br>M(x, 0) &amp;= e(x, 0) \newline<br>\end{aligned}<br>$$</p><p>对于其他的所有像素，我们需要查看上一行的像素。由于接缝需要是相连的，我们的候选只有左上方、上方、右上方三个最近的像素。我们要选取以这些像素结尾的接缝中能量最低的那个，然后加上当前像素的能量：</p><p>$$<br>\begin{aligned}<br>M(x, y) &amp;= e(x, y) + \min \begin{cases}<br>                          M(x - 1, y - 1) \newline<br>                          M(x, y - 1) \newline<br>                          M(x + 1, y - 1)<br>                          \end{cases}<br>\end{aligned}<br>$$</p><p>我们需要考虑所查看的像素位于图片的左边缘或右边缘时的边界情况。对于左、右边缘处的像素，我们分别忽略 $M(x - 1, y - 1)$  或者 $M(x + 1, y - 1)$。</p><p>最终，我们需要取得竖向延伸了整个图片的最低能量接缝的能量。这意味着查看图片的最底行，选择以这些像素中的一个结尾的最低能量接缝。设图片宽 $W$ 个像素，高 $H$ 个像素，我们要的是：</p><p>$$<br>\min_{0 \le x &lt; W} M(x, H - 1)<br>$$</p><p>有了这个定义，我们就得到了一个递归关系，包括我们所需的所有性质：</p><ul><li>递归关系的输入为整数。</li><li>我们所需的最终结果易于从递归关系中提取。</li><li>这个关系只依赖于自身。</li></ul><h4 id="检查子问题的-DAG（有向无环图）"><a href="#检查子问题的-DAG（有向无环图）" class="headerlink" title="检查子问题的 DAG（有向无环图）"></a>检查子问题的 DAG（有向无环图）</h4><p>由于每个子问题 $M(x,y)$ 对应于原图片中的单个像素，子问题的依赖图非常容易可视化，只需将子问题放在二维网格中，就像在原图片中的排列一样！</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-layout.png" alt="子问题放置在二维网格中，就像在原图片中的排列一样。"></p><p>如递归关系的基本情况（base case）所示，最顶行的子问题对应于图片的最顶行，可以简单地用单个像素的能量值初始化。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-top-row.png" alt="子问题的第一行不依赖于任何其他子问题。注意最顶行的单元没有出来的箭头。"></p><p>从第二行开始，依赖关系开始出现。首先，在第二行的最左单元，我们遇到了一个边界情况。由于左侧没有其他单元，标记为 $(0,1)$ 的单元只依赖于上方和右上方最近的单元。对于第三行最左侧的单元来说也是同样的情况。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-left-edge.png" alt="左边缘处的子问题只依赖于上方的两个子问题。"></p><p>再看第二行的第二个单元，标记为 $(1,1)$ 的单元。这是递归关系的一个最典型的展示。这个单元依赖于左上、上方、右上最近的三个单元。这种依赖结构适用于第二行及以后的所有“中间”的单元。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-middle-cell.png" alt="左右边缘之间的子问题依赖于上方的三个子问题。"></p><p>第二行的最后，右边缘处表示了第二个边界情况。因为右侧没有其他单元，这个单元只依赖于上方和左上最近的单元。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-right-edge.png" alt="右边缘处的子问题只依赖于上方的两个子问题。"></p><p>最后，对所有后续行重复这个过程。</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/dag-animation.gif" alt="因为依赖于包含了太多的箭头，这里的动画逐个显示了每个子问题的依赖。"></p><p>由于完整的依赖图箭头数量极多，令人生畏，逐个地观察每个子问题能让我们建立直观的依赖模式。</p><h4 id="自底向上的实现"><a href="#自底向上的实现" class="headerlink" title="自底向上的实现"></a>自底向上的实现</h4><p>从上述分析中，我们可以得到子问题的顺序：</p><ul><li>从图片的顶部到底部。</li><li>对于每一行，可以以任意顺序。自然的顺序是从左至右。</li></ul><p>因为每一行只依赖于前一行，所以我们只需要维护两行的数据：前一行和当前行。实际上，如果从左至右计算，我们实际上可以丢弃前一行使用过的一些元素。不过，这会让算法更复杂，因为我们需要弄清楚前一行的哪部分可以丢弃，以及如何丢弃。</p><p>在下面的 Python 代码中，输入是行的列表，其中每行是数字的列表，表示这一行中每个像素的能量。输入命名为  <code>pixel_energies</code>，而 <code>pixel_energies[y][x]</code> 表示位于坐标 $(x,y)$ 处像素的能量。</p><p>首先计算最顶行的接缝的能量，只需拷贝最顶行的单个像素的能量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous_seam_energies_row = list(pixel_energies[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>接着，循环遍历输入的其余行，计算每行的接缝能量。最棘手的部分是确定引用前一行中的哪些元素，因为左边缘像素的左侧和右边缘像素的右侧是没有像素的。</p><p>在每次循环中，会为当前行创建一个新的接缝能量的列表。每次循环结束时，将前一行的数据替换为当前行的数据，供下一轮循环使用。这样我们就丢弃了前一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在循环中跳过第一行</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, len(pixel_energies)):</span><br><span class="line">    pixel_energies_row = pixel_energies[y]</span><br><span class="line"></span><br><span class="line">    seam_energies_row = []</span><br><span class="line">    <span class="keyword">for</span> x, pixel_energy <span class="keyword">in</span> enumerate(pixel_energies_row):</span><br><span class="line">        <span class="comment"># 判断要在前一行中遍历的 x 值的范围。这个范围取决于当前像素是在图片</span></span><br><span class="line">        <span class="comment"># 的中间还是边缘。</span></span><br><span class="line">        x_left = max(x - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        x_right = min(x + <span class="number">1</span>, len(pixel_energies_row) - <span class="number">1</span>)</span><br><span class="line">        x_range = range(x_left, x_right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        min_seam_energy = pixel_energy + \</span><br><span class="line">            min(previous_seam_energies_row[x_i] <span class="keyword">for</span> x_i <span class="keyword">in</span> x_range)</span><br><span class="line">        seam_energies_row.append(min_seam_energy)</span><br><span class="line"></span><br><span class="line">    previous_seam_energies_row = seam_energies_row</span><br></pre></td></tr></table></figure><p>最终， <code>previous_seam_energies_row</code> 包含了最底行的接缝能量。取出这个列表中的最小值，这就是答案！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(seam_energy <span class="keyword">for</span> seam_energy <span class="keyword">in</span> previous_seam_energies_row)</span><br></pre></td></tr></table></figure><p>你可以测试这个实现：把它包装在一个函数中，然后创建一个二维数组作为输入调用这个函数。下面的输入数据会让贪心算法失败，但同时也有明显可见的最低能量接缝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENERGIES = [</span><br><span class="line">    [<span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(min_seam_energy(ENERGIES))</span><br></pre></td></tr></table></figure><h4 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h4><p>对于原图片中的每一个像素，都有一个对应的子问题。每个子问题最多有 3 个依赖，所以解决每个子问题的工作量是常数。最后，我们需要再遍历最后一行一遍。那么，如果图片宽 $W$ 像素，高 $H$ 像素，时间复杂度是 $O(W \times H + W)$。</p><p>在任意时刻，我们持有两个列表，分别存储前一行和当前行。前一行的列表共有 $W$ 个元素，而当前行的列表不断增长，最多有 $W$ 个元素。那么，空间复杂度是 $O(2W)$，也就是 $O(W)$。</p><p>注意到，如果我们真的从前一行的数据中丢弃一部分元素，我们可以在当前行的列表增长的同时缩减前一行的列表。不过，空间复杂度仍旧是 $O(W)$。取决于图片的宽度，常量系数可能会有一点影响，但通常不会有什么大的影响。</p><h2 id="用于寻找最低能量接缝的后向指针"><a href="#用于寻找最低能量接缝的后向指针" class="headerlink" title="用于寻找最低能量接缝的后向指针"></a>用于寻找最低能量接缝的后向指针</h2><p>现在我们找到了最低能量垂直接缝的能量，那么如何利用这个信息呢？事实上我们并不关心接缝的能量，而是接缝本身！问题是，从接缝的最后一个像素，我们无法回溯到接缝的其余部分。</p><p>这是我在文章前面的内容中跳过的部分，但很多动态规划的问题也有相似的考虑。例如，如果你还记得<a href="https://medium.com/future-vision/a-graphical-introduction-to-dynamic-programming-2e981fa7ca2?source=friends_link&amp;sk=37cd14642cf1a83eb0bb33d231442837#25bc" target="_blank" rel="noopener">盗贼问题</a>，我们可以知道盗窃的数值并提取出最大值，但我们不知道哪些房子产出了那个总和的值。</p><h4 id="表示后向指针"><a href="#表示后向指针" class="headerlink" title="表示后向指针"></a>表示后向指针</h4><p>解决方法是通用的：存储<strong>后向指针</strong>。在接缝裁剪的问题中，我们不仅需要每个像素处的接缝能量值，还想要知道前一行的哪个像素得到了这个能量。通过存储这个信息，我们可以沿着这些指针一路到达图片的顶部，得到组成了最低能量接缝的像素。</p><p>首先，我们创建一个类来存储一个像素的能量和后向指针。能量值会用来计算子问题。因为后向指针只是记录了前一行的哪个像素产生了当前的能量，我们可以只用 $x$ 坐标来表示这个指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeamEnergyWithBackPointer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, energy, x_coordinate_in_previous_row=None)</span>:</span></span><br><span class="line">        self.energy = energy</span><br><span class="line">        self.x_coordinate_in_previous_row = \</span><br><span class="line">            x_coordinate_in_previous_row</span><br></pre></td></tr></table></figure><p>每个子问题将会是这个类的一个实例，而不再只是一个数字。</p><h4 id="存储后向指针"><a href="#存储后向指针" class="headerlink" title="存储后向指针"></a>存储后向指针</h4><p>在最后，我们需要回溯整个图片的高度，沿着后向指针重建最低能量的接缝。不幸的是，这意味着我们需要存储图片中<strong>所有的</strong>像素，而不仅是前一行。</p><p>为了实现这一点，我们将保留所有子问题的全部结果，即使可以丢弃前面行的接缝能量数值。我们可以用像输入的数组一样的二维数组来存储这些结果。</p><p>让我们从第一行开始，这一行只包含单个像素的能量。由于没有前一行，所有的后向指针都是 <code>None</code>。但是为了一致性，我们还是会存储 <code>SeamEnergyWithBackPointer</code> 的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seam_energies = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝最顶行的像素能量来初始化最顶行的接缝能量。最顶行没有后向指针。</span></span><br><span class="line">seam_energies.append([</span><br><span class="line">    SeamEnergyWithBackPointer(pixel_energy)</span><br><span class="line">    <span class="keyword">for</span> pixel_energy <span class="keyword">in</span> pixel_energies[<span class="number">0</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>主循环的工作方式几乎和先前的实现相同，除了以下几点区别：</p><ul><li>前一行的数据包含的是 <code>SeamEnergyWithBackPointer</code> 的实例，所以当计算递归关系的值时，我们需要在这些对象内部查找接缝能量。</li><li>当为当前像素存储数据时，我们需要创建一个新的 <code>SeamEnergyWithBackPointer</code> 实例。在这个实例中我们既存储当前像素的接缝能量，又存储用于计算当前接缝能量的前一行的 $x$ 坐标。</li><li>在每一行计算结束后，不会丢弃前一行的数据，而是简单地将当前行的数据追加到 <code>seam_energies</code> 中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在循环中跳过第一行</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, len(pixel_energies)):</span><br><span class="line">    pixel_energies_row = pixel_energies[y]</span><br><span class="line"></span><br><span class="line">    seam_energies_row = []</span><br><span class="line">    <span class="keyword">for</span> x, pixel_energy <span class="keyword">in</span> enumerate(pixel_energies_row):</span><br><span class="line">        <span class="comment"># 判断要在前一行中遍历的 x 值的范围。这个范围取决于当前像素是在图片</span></span><br><span class="line">        <span class="comment"># 的中间还是边缘。</span></span><br><span class="line">        x_left = max(x - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        x_right = min(x + <span class="number">1</span>, len(pixel_energies_row) - <span class="number">1</span>)</span><br><span class="line">        x_range = range(x_left, x_right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        min_parent_x = min(</span><br><span class="line">            x_range,</span><br><span class="line">            key=<span class="keyword">lambda</span> x_i: seam_energies[y - <span class="number">1</span>][x_i].energy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        min_seam_energy = SeamEnergyWithBackPointer(</span><br><span class="line">            pixel_energy + seam_energies[y - <span class="number">1</span>][min_parent_x].energy,</span><br><span class="line">            min_parent_x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        seam_energies_row.append(min_seam_energy)</span><br><span class="line"></span><br><span class="line">    seam_energies.append(seam_energies_row)</span><br></pre></td></tr></table></figure><h4 id="沿着后向指针前进"><a href="#沿着后向指针前进" class="headerlink" title="沿着后向指针前进"></a>沿着后向指针前进</h4><p>当全部的子问题表格都填满后，我们就可以重建最低能量的接缝。首先找到最底行对应于最低能量接缝的 x 坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到最底行接缝能量最低的 x 坐标</span></span><br><span class="line">min_seam_end_x = min(</span><br><span class="line">    range(len(seam_energies[<span class="number">-1</span>])),</span><br><span class="line">    key=<span class="keyword">lambda</span> x: seam_energies[<span class="number">-1</span>][x].energy</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，从图片的底部走向顶部，$y$ 坐标从 <code>len(seam_energies) - 1</code> 降到 <code>0</code>。 在每轮循环中，将当前的 $(x,y)$ 坐标对添加到表示接缝的列表中，然后将 $x$  的值设为当前行的 <code>SeamEnergyWithBackPointer</code> 对象所指向的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿着后向指针前进，得到一个构成最低能量接缝的坐标列表</span></span><br><span class="line">seam = []</span><br><span class="line">seam_point_x = min_seam_end_x</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(len(seam_energies) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    seam.append((seam_point_x, y))</span><br><span class="line"></span><br><span class="line">    seam_point_x = \</span><br><span class="line">        seam_energies[y][seam_point_x].x_coordinate_in_previous_row</span><br><span class="line"></span><br><span class="line">seam.reverse()</span><br></pre></td></tr></table></figure><p>这样就自底向上地构建出了接缝，将列表反转就得到了自顶向下的接缝坐标。</p><h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><p>时间复杂度和之前相似，因为我们仍然需要将每个像素处理一次。在最后还需要从最后一行中找出最低的接缝能量，然后向上走一个图片的高度来重建接缝。那么，对于 $W \times H$ 的图片，时间复杂度是 $O(W \times H + W + H)$。</p><p>至于空间复杂度，我们仍然为每个子问题存储常量级的数据，但是现在我们不再丢弃任何数据。那么，我们使用了 $O(W \times H)$ 的空间。</p><h2 id="删除低能量的接缝"><a href="#删除低能量的接缝" class="headerlink" title="删除低能量的接缝"></a>删除低能量的接缝</h2><p>找到了最低能量的垂直接缝后，我们可以简单地将原图片中的像素复制到新图片中。新图片中的每一行都是原图片中对应行除去最低能量接缝的像素后的剩余像素。因为我们在每一行都删去了一个像素，那么我们可以从一个 $W \times H$ 的图片得到 $(W-1) \times H$ 的图片。</p><p>我们可以重复这个过程，在新图片上重新计算能量函数，然后找到新图片上的最低能量接缝。你可能很想在原图片上找到不止一个低能量的接缝，然后一次性把它们都删除。但问题是两个接缝可能相关交叉，在中间共享同一个像素。在第一个接缝删掉之后，第二个接缝就会由于缺少了一个像素而不再有效。</p><p>上述视频展示了应用于冲浪者图片上的接缝删除过程（视频链接<a href="https://youtu.be/B9HPREBePI4" target="_blank" rel="noopener">在此</a>——译者注）。我是通过获取每次迭代的图片，然后在上面添加最低能量接缝的可视化线条来制作的这个视频。</p><h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><p>已经有很多深入的讲解了，那让我们以一些漂亮的照片结束吧！请看下面的在拱门国家公园的岩层的照片：</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/arch.jpg" alt="拱门国家公园中间的一个有孔的岩层。图片来自 [Flickr](https://flic.kr/p/4hxxz5) 上的 [Mike Goad](https://www.flickr.com/photos/exit78/)。"></p><p>这个图片的能量函数：</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/arch-energy.jpg" alt="拱门图片中每个像素的能量，用白色显示高能量像素、黑色显示低能量像素来可视化。注意岩层孔洞边缘旁的高能量。"></p><p>这产生了下面的最低能量接缝。注意到这个接缝穿过了右侧的岩石，正好从岩石顶部被照亮与天空颜色一致的部分进入。或许我们需要选择一个更好的能量函数！</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/arch-seam.jpg" alt="拱门图片中的最低能量接缝。接缝通过一条五个像素宽的红线来可视化，实际上接缝只有一个像素宽。"></p><p>最终，调整拱门图片的大小之后：</p><p><img src="/posts/2019/real-world-dynamic-programming-seam-carving/arch-resized.jpg" alt="宽度减少了 1024 像素后的拱门图片。"></p><p>这个结果肯定不太完美，原图片中的很多边缘在调整大小后的图片中都有些变形。一种可能的改进是实现另一个论文中讨论的能量函数。</p><hr><p>动态规划虽然常常只在教学中遇到，但它还是解决实际的复杂问题的有用技术。在本文中，我们讨论了动态规划的一个应用：使用接缝裁剪实现环境敏感的图片大小调整。</p><p>我们应用了相同的原理，将问题分解为子问题，分析子问题之间的依赖关系，然后以时间、空间复杂度最小的顺序求解。另外，我们还探索了通过后向指针，除了计算最小的数值，还能找到产生这个数值的特定选择。然后将这部分内容应用到实际的问题上，对问题进行预处理和后处理，让动态规划算法真正有用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在&lt;strong&gt;掘金翻译计划&lt;/strong&gt;中的译文。 译文链接：&lt;a href=&quot;https://juejin.im/post/5de8b483f265da33d039c618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[译] 动态规划算法的实际应用：接缝裁剪&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://avikdas.com/2019/05/14/real-world-dynamic-programming-seam-carving.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Real-world dynamic programming: seam carving&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://avikdas.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Avik Das&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/real-world-dynamic-programming-seam-carving.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/real-world-dynamic-programming-seam-carving.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/nettee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/JalanJiang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JalanJiang&lt;/a&gt;，&lt;a href=&quot;https://github.com/TokenJan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TokenJan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;我们一直认为动态规划（dynamic programming）是一个在学校里学习的技术，并且只是用来通过软件公司的面试。实际上，这是因为大多数的开发者不会经常处理需要用到动态规划的问题。本质上，&lt;strong&gt;动态规划可以高效求解那些可以分解为高度重复子问题的问题&lt;/strong&gt;，因此在很多场景下是很有用的。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将会仔细分析动态规划的一个有趣的实际应用：接缝裁剪（seam carving）。&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=1276390&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Avidan 和 Shamir 的这篇文章 &lt;strong&gt;Seam Carving for Content-Aware Image Resizing&lt;/strong&gt;&lt;/a&gt; 中详细讨论了这个问题以及提出的技术（搜索文章的标题可以免费获取）。&lt;/p&gt;
&lt;p&gt;这篇文章是动态规划的系列文章中的一篇。如果你还不了解动态规划技术，请参阅我写的&lt;a href=&quot;https://medium.com/future-vision/a-graphical-introduction-to-dynamic-programming-2e981fa7ca2?source=friends_link&amp;amp;sk=37cd14642cf1a83eb0bb33d231442837&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态规划的图形化介绍&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;环境敏感的图片大小调整&quot;&gt;&lt;a href=&quot;#环境敏感的图片大小调整&quot; class=&quot;headerlink&quot; title=&quot;环境敏感的图片大小调整&quot;&gt;&lt;/a&gt;环境敏感的图片大小调整&lt;/h2&gt;&lt;p&gt;为了用动态规划解决实际问题，我们需要将问题建模为可以应用动态规划的形式。本节介绍了这个问题的必要的准备工作。&lt;/p&gt;
&lt;p&gt;论文的原作者介绍了一种在智能考虑图片内容的情况下改变图片的宽度或高度的方法，叫做环境敏感的图片大小调整（content-aware image resizing）。后面会介绍论文的细节，但这里先做一个概述。假设你想调整下面这个冲浪者图片的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/2019/real-world-dynamic-programming-seam-carving/surfer.jpg&quot; alt=&quot;一个冲浪者在平静的海面中间清晰可见的俯视图，右边是身后汹涌的海浪。图片来自 [Pixabay](https://pixabay.com/photos/blue-beach-surf-travel-surfer-4145659/) 上的 [Kiril Dobrev](https://pixabay.com/users/kirildobrev-12266114/)。&quot;&gt;&lt;/p&gt;
&lt;p&gt;论文中详细讨论了，有多种方法可以减少图片的宽度。我们最先想到的是裁剪和缩放，以及它们相关的缺点。删除图片中部的几列像素也是一种方法，但你也可以想象得到，这样会在图片中留下一条可见的分割线，左右的内容无法对齐。而且即使是这些方法全用上了，也只能删掉这么点图片：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="图像" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何手写一个简单的 parser</title>
    <link href="http://yoursite.com/posts/2019/How-to-write-a-simple-parser-in-hand/"/>
    <id>http://yoursite.com/posts/2019/How-to-write-a-simple-parser-in-hand/</id>
    <published>2019-08-04T09:32:24.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子，收到烨兄的私聊，他突然要解决这样一个任务：</p><blockquote><p>做如下格式的表达式转换：</p><ul><li><code>Multi(a, Multi(b, c))  --&gt;  a * (b * c)</code></li><li><code>Divide(a, Sub(b, c))  --&gt; a / (b - c)</code></li></ul><p>支持的运算符有：</p><ul><li><code>Add</code>: +</li><li><code>Sub</code>: -</li><li><code>Multi</code>: *</li><li><code>Divide</code>: /</li></ul></blockquote><p>而且好死不死的需要用他没怎么用过的 C++ 来写。我发现这是一个 parser 的问题，第一反应是推荐他用 flex/bison，但想到为了这么大点任务大费周章不太合适，又开始想手写这样一个表达式的 parser 难不难。最后得出的结论是，不难。</p><p>了解编译原理的人都知道什么是 parser。Parser 中文名（语法）分析器，是每个编译器的前端都会有的一个东西。不过，从编译原理的视角来看，“语言”的范畴要比我们理解的编程语言要广义得多，任何有一定规则的字符串构成方式，都可以看成是语言，例如上面的那个任务里用 <code>Add</code>、<code>Sub</code> 这样的函数描述的表达式。</p><p>那么，要解决上面这个任务，只需要对表达式的字符串进行语法分析，得到一个中间表示（一般是分析树或抽象语法树），再将中间表示输出为所需的格式即可。也就是说我们需要为表达式提供一个 parser，这个任务的任何解决方式，本质上都可以看成是写了一个 parser。</p><a id="more"></a><p>在平时，我们完全没有任何必要去手写一个 parser，因为这东西已经有工具可以为我们生成。感谢几十年前伟大的程序员就已经发明了这样的工具。我用过的有 C/C++ 的 flex/bison，以及 Java 的 ANTLR。你只需要提供一个文法描述，这些工具就可以为你自动生成对应的语法分析器。如果要手写分析器，会很复杂，也很容易出错，不是一个明智的选择。</p><p>不过，面对上面举例的这种小任务，使用自动生成 parser 的工具有时候显得太重了，这时候也许手写一个 parser 是更好的选择。而且在这样的任务场景下，我们的 parser 有两个地方起码是可以得到大大简化的：</p><p>第一，我们要处理的语言应该不会像通用编程语言那样，有很复杂的状态转移。通常情况下，应该能看到当前的字符串就知道下面要分析什么类型的内容。一般标记语言都会是这种风格的，比如：</p><ul><li>XML/HTML：看到 <code>&lt;tag&gt;</code> 就知道是一个标签的开始，直到 <code>&lt;/tag&gt;</code> 为止</li><li>CSS：选择器后的声明，总是用花括号括起来，每一条声明以 <code>;</code> 分隔</li><li>Markdown：一行以 <code>#</code> 开头就是标题，以 <code>1.</code> 开头就是有序列表项</li></ul><p>第二，我们不需要进行复杂的语法错误处理，只需要报“语法错误”就好了，而不需要费力说明到底发生了什么错误。</p><p>有了这两个前提，我们开始思考如何手写一个语法分析器。当然，我已经思考好了，下面是我给出的一个简单的分析器的实现。我是用 Java 实现的，用到了一点 lambda 表达式的语法，不过不难理解。因为 parser 的主要工作是做字符串比较，所以用任何语言都差不多。后面我会考虑再用其他语言实现。</p><p>在实现上我们再做一点简化：我们把要分析的字符串作为字符数组保存下来，而不是从所谓“字符流”中读入。这样我们不必考虑读 (get) 了字符却不用掉 (consume) 的情况下，这些是输入模块要考虑的部分，我们专注于 parser 本身。</p><p>首先，我们的 <code>SimpleParser</code> 是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] input;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleParser</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = source.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将输入保存为字符数组，<code>pos</code> 是一个指向待读取的下一个字符的指针。将 <code>pos</code> 加一，就相当于从读入了一个字符。</p><p>下面，我们添加一些脚手架函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeWhitespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    consumeWhile(Character::isWhitespace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">consumeWhile</span><span class="params">(Predicate&lt;Character&gt; test)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!eof() &amp;&amp; test.test(nextChar())) &#123;</span><br><span class="line">        sb.append(consumeChar());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">consumeChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input[pos++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(input, pos, input.length - pos).startsWith(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">eof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos &gt;= input.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数的来源于我之前看过的一个系列文章：<a href="https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html" target="_blank" rel="noopener">Let’s build a browser engine!</a>（原文是用 Rust 语言的）。我们来看一下这几个函数：</p><p>其中，<code>nextChar</code>, <code>startsWith</code> 这两个函数是用来“向后看”，判断后面输入的状态。这实际上已经和编译原理中说的语法分析不太一样了（回忆一下，编译原理中说的语法分析方法只会向后看一个字符），但是因为我们只是判断是不是等于一个固定的字符串，所以也不是太大的问题。</p><p>以 <code>consume...</code> 开头的几个函数就是真正的读取输入的函数了。其中，<code>consumeWhile</code> 是一个通用的函数，<code>consumeWhitespace</code> 也是基于其实现的。类似地，我们还可以基于其实现解析变量名的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">parseVariableName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> consumeWhile(Character::isAlphabetic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这实际上就是在解析我们任务中的变量名了，以此为思路，后面的实现其实很简单。我们一上来会觉得手写 parser 会很复杂，实际上是因为没找到入手点。所以这几个脚手架函数特别重要，先有了他们，后面就可以一步一步写出整个 parser 的功能了。</p><p>那么我们接下来可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析由单个变量组成的表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> VariableExpression <span class="title">parseVariableExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String name = parseVariableName();</span><br><span class="line">    <span class="comment">// VariableExpression 的定义略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VariableExpression(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析加减乘除表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompoundExpression <span class="title">parseCompoundExpression</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : name.toCharArray()) &#123;</span><br><span class="line">        checkState(c == consumeChar());</span><br><span class="line">    &#125;</span><br><span class="line">    checkState(<span class="string">'('</span> == consumeChar());</span><br><span class="line">    <span class="comment">// 递归解析</span></span><br><span class="line">    Expression left = parseExpression();</span><br><span class="line">    checkState(<span class="string">','</span> == consumeChar());</span><br><span class="line">    consumeWhitespace();</span><br><span class="line">    Expression right = parseExpression();</span><br><span class="line">    checkState(<span class="string">')'</span> == consumeChar());</span><br><span class="line">    <span class="comment">// CompoundExpression 的定义略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundExpression(name, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VariableExpression 和 CompoundExpression 都是 Expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">parseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startsWith(<span class="string">"Add"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseCompoundExpression(<span class="string">"Add"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startsWith(<span class="string">"Sub"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseCompoundExpression(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startsWith(<span class="string">"Multi"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseCompoundExpression(<span class="string">"Multi"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startsWith(<span class="string">"Divide"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseCompoundExpression(<span class="string">"Divide"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parseVariableExpression();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这里，我们 parser 的主要工作已经做完了，接下来的任务就非常简单了。似乎我们的任务有点太简单了？在这种场景下，手写 parser 确实不难，接下来可以手写一个 Markdown 的 parser 练习一下了😜。</p><p>P.S. 烨兄后来并没有做这个任务，我也是到现在才想起来把这个 parser 实现出来，只是我自己觉得好玩想了这件事。</p><p>文章中的 parser 的完整代码，可以到我的 GitHub 上查看：<a href="https://github.com/nettee/simpleparser" target="_blank" rel="noopener">simpleparser</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子，收到烨兄的私聊，他突然要解决这样一个任务：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做如下格式的表达式转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Multi(a, Multi(b, c))  --&amp;gt;  a * (b * c)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Divide(a, Sub(b, c))  --&amp;gt; a / (b - c)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持的运算符有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Add&lt;/code&gt;: +&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sub&lt;/code&gt;: -&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Multi&lt;/code&gt;: *&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Divide&lt;/code&gt;: /&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;而且好死不死的需要用他没怎么用过的 C++ 来写。我发现这是一个 parser 的问题，第一反应是推荐他用 flex/bison，但想到为了这么大点任务大费周章不太合适，又开始想手写这样一个表达式的 parser 难不难。最后得出的结论是，不难。&lt;/p&gt;
&lt;p&gt;了解编译原理的人都知道什么是 parser。Parser 中文名（语法）分析器，是每个编译器的前端都会有的一个东西。不过，从编译原理的视角来看，“语言”的范畴要比我们理解的编程语言要广义得多，任何有一定规则的字符串构成方式，都可以看成是语言，例如上面的那个任务里用 &lt;code&gt;Add&lt;/code&gt;、&lt;code&gt;Sub&lt;/code&gt; 这样的函数描述的表达式。&lt;/p&gt;
&lt;p&gt;那么，要解决上面这个任务，只需要对表达式的字符串进行语法分析，得到一个中间表示（一般是分析树或抽象语法树），再将中间表示输出为所需的格式即可。也就是说我们需要为表达式提供一个 parser，这个任务的任何解决方式，本质上都可以看成是写了一个 parser。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Compiler" scheme="http://yoursite.com/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>[译] 重试、超时和退避</title>
    <link href="http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/"/>
    <id>http://yoursite.com/posts/2019/Retries-Timeouts-and-Backoff/</id>
    <published>2019-07-30T13:52:39.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在<strong>掘金翻译计划</strong>中的译文。 译文链接：<a href="https://juejin.im/post/5ccf98ace51d456e6d133541" target="_blank" rel="noopener">[译] 分布式系统如何从故障中恢复？— 重试、超时和退避</a></p><blockquote><ul><li>原文地址：<a href="https://namc.in/2019-04-15-retries-timeouts-backoff" target="_blank" rel="noopener">Retries, Timeouts and Backoff</a></li><li>原文作者：<a href="http://namc.in/" target="_blank" rel="noopener">namc</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md</a></li><li>译者：<a href="https://github.com/nettee" target="_blank" rel="noopener">nettee</a></li><li>校对者：<a href="https://github.com/fireairforce" target="_blank" rel="noopener">fireairforce</a></li></ul></blockquote><hr><p>分布式系统很难。即使我们学了很多构建高可用性系统的方法，也常常会忽略系统设计中的弹性（resiliency）。</p><p>我们肯定听说过容错性，但什么是“弹性”呢？个人而言，我喜欢将其定义为系统处理意外情况并最终从中恢复的能力。有很多方法使你的系统能从故障中回弹，但在这篇文章中，我们主要关注以下几点：</p><ul><li><a href="#超时">超时</a></li><li><a href="#重试">重试</a></li><li><a href="#退避">退避</a></li><li><a href="#分布式系统中的幂等性">分布式系统中的幂等性</a></li></ul><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>简单来说，超时就是两个连续的数据包之间的最大不活动时间。</p><p>假设我们在某个时刻已经使用过了数据库驱动和 HTTP 客户端。所有帮助你的服务连接到一个外部服务器的客户端或驱动都有 Timeout 参数。这个参数通常默认为零或 -1，表示超时时间未定义，或是无限时间。</p><p>例如：参考 <code>connectTimeout</code> 和 <code>socketTimeout</code> 的定义 <a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">Mysql Connector 配置</a></p><p>大多数对外部服务器的请求都附有一个超时时间。当外部服务器没有及时响应时，超时的设置非常有必要。如果没有设置超时，并使用默认值 0/-1，你的程序可能会阻塞几分钟或更长的时间。这是因为，当你没有收到来自应用服务器的响应，并且你的超时时间无限或非常大时，这个连接会一直开着。随着有更多的请求到来，更多的连接会打开，并永远无法关闭。这会导致你的连接池耗尽，进而导致你的应用的故障。</p><a id="more"></a><p>那么，每当你使用这样的连接器来配置你的应用时，请务必在配置中设置显式的超时值。</p><p>超时必须在前端和后端中都实现。如果一个读/写操作在一个 REST API 或 socket 接口上阻塞了太长时间，它应当抛出异常，并且断开连接。这可以通知后端取消操作并关闭连接，从而防止连接始终打开。</p><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>我们可能需要了解<strong>瞬时故障</strong>这个术语，因为我们后面会频繁用到它。简单地说，服务中的瞬时故障是一种暂时的失灵，例如网络拥塞，数据库过载，是一种在有足够的冷却周期之后也许能自己恢复的故障。</p><p><strong>如何判断一个故障是否是瞬时的？</strong></p><p>答案取决于你的 API/Server 响应的实现细节。如果你有一个 REST API，请返回 <a href="https://tools.ietf.org/html/rfc7231#section-6.6.1" target="_blank" rel="noopener">503 Service Unavailable</a>，而不是其他 5xx/4xx 错误码。这可以让客户端知道超时是由“临时的过载”引起的，而不是由于代码层面的错误。</p><p>重试虽然有用，但如果没有正确地配置，则会让人讨厌。下面阐述了如何找出正确的重试方法。</p><p><strong>重试</strong></p><p>如果从服务器收到的错误是瞬时的，例如网络数据包在传输时损坏，应用程序可以立即重试请求，因为故障不太可能再次发生。</p><p>然而，这种方法非常激进。如果你的服务已经满负荷运行，或是已经完全不可用，这种方法可能对你的服务有害。这种方法还会拖慢应用的响应时间，因为你的服务会尝试不断执行一个失败的操作。</p><p>如果你的业务逻辑需要这样的重试策略，你最好限制重试的次数，不向同一个源头发送过多的请求。</p><p><strong>带延迟的重试</strong></p><p>如果是连接失败或网络上的过大流量导致的故障，应用程序则应当根据业务逻辑，在重试请求之前添加延迟时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    Thread.Sleep(50); // 延迟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用一个连接至外部服务的库时，请检查它是否实现了重试策略，允许你配置重试的最大次数、重试之间的延迟等。</p><p>你还可以通过设置 <a href="https://tools.ietf.org/html/rfc7231#section-7.1.3" target="_blank" rel="noopener">Retry-After</a> 响应头，在服务器端实现重试的策略。</p><p>用日志记录操作失败的原因也很重要。有时候操作失败是因为缺少资源，这可以通过添加更多的服务实例来解决。也有时候操作失败可能是因为内存泄漏或空指针异常。那么，添加日志跟踪你的应用程序的行为就很重要了。</p><h2 id="退避"><a href="#退避" class="headerlink" title="退避"></a>退避</h2><p>如上所述，我们可以向重试策略中添加延迟。这种延迟通常称为<strong>线性退避</strong>。这可能不是实现一个重试策略的最佳方法。</p><p>考虑这种情况：你的服务因为数据库的过载发生了故障。我们的请求很可能在几次重试之后会成功。但不断发送的请求也可能<strong>加重</strong>你的数据库服务器的过载问题。因此，数据库服务会在过载状态停留更长时间，也会需要更多的时间从过载状态中恢复。</p><p>有几种策略可以用于解决这个问题。</p><p><strong>1. <a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数退避</a></strong></p><p>顾名思义，指数退避不是在重试之间进行周期性的延迟（例如 5 秒），而是指数性地增加延迟时间。重试会一直进行到最大次数限制。如果请求始终失败，就告诉客户端请求失败了。</p><p>你还必须设置最大延迟时间的限制。指数退避可能导致出现非常大的延迟时间，导致请求的 socket 保持无限期开启，并使线程“永远”休眠。这会耗尽系统资源，导致连接池的更多问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int delay = 50</span><br><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(delay);</span><br><span class="line">    if (delay &lt; MAX_DELAY)      // MAX_DELAY 可能依赖于应用程序和业务逻辑</span><br><span class="line">    &#123;</span><br><span class="line">        delay *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指数退避在分布式系统中的一个主要缺点是，<strong>在同一时间开始退避的请求，也会在同一时间进行重试</strong>。这导致了请求簇的出现。那么，我们并没有减少每一轮进行竞争的客户端数量，而是引入了没有客户端竞争的时期。固定的指数退避并不能减少很多竞争，并会生成<strong>负载峰值</strong>。</p><p><strong>2. <a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">带抖动的退避</a></strong></p><p>为了处理指数退避的负载峰值问题，我们向退避策略中添加<strong>抖动</strong>。抖动是一种去相关性策略，在重试的间隔中添加随机性，从而分摊了负载，避免了出现网络请求簇。</p><p>抖动通常不是任何一项配置属性，需要客户端来实现。抖动所需要的只是一个可以加入随机性的函数，可以在重试之前动态地计算出等待的时间。</p><p>引入抖动之后，最初的一组失败的请求可能聚集在一个很小的窗口中，例如 100 ms。但是在每个重试周期之后，请求簇会摊开到越来越大的时间窗口中。当请求分摊在足够大的窗口上时，服务就很可能能够处理这些请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int delay = 50</span><br><span class="line">for(int attempts = 0; attempts &lt; 5; attempts++)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        DoWork();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(delay);</span><br><span class="line">    delay *= random.randrange(0, min(MAX_DELAY, delay * 2 ** i)) // 只是生成一个简单的随机数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>长时间的瞬时故障</strong>的情况下，任何的重试可能都不是最好的方法。这种故障可能是由于连接失效，电力中断（是的，非常真实的情况）导致的。客户端最终会重试若干次，浪费了系统资源，并进一步导致了更多系统中的故障。</p><p>那么，我们需要一种可以确定故障是否会长期持续的机制，并实现一种应对该情况的解决方案。</p><p><strong>3. <a href="https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern" target="_blank" rel="noopener">断路器</a></strong></p><p>断路器模式在处理服务的长时间瞬时故障时非常有用。它通过确定服务的可用性，防止客户端重试注定会失败的请求。</p><p>断路器设计模式要求在一系列的请求中保留连接的状态。让我们看看 <a href="https://github.com/jhalterman/failsafe#circuit-breakers" target="_blank" rel="noopener">failsafe 实现的断路器</a></p><pre><code>CircuitBreaker breaker = new CircuitBreaker()  .withFailureThreshold(5)  .withSuccessThreshold(3)  .withDelay(1, TimeUnit.MINUTES);Failsafe.with(breaker).run(() -&gt; connect());</code></pre><p>当一切正常运行时，没有故障，断路器保持在关闭状态。</p><p>当达到执行故障的阈值时，断路器跳闸并进入<strong>打开</strong>状态。这意味着，后续的所有请求会直接失败，不会经过重试的逻辑。</p><p>经过一段延迟之后（如上述设置的 1 分钟），断路器会进入<strong>半开</strong>状态，测试网络请求的问题是否依然存在，并决定断路器是应当关闭还是打开。如果请求成功，断路器会重置为<strong>关闭</strong>状态，否则会重新置为<strong>打开</strong>状态。</p><p>这有助于在长时间的故障中避免重试执行的聚集，节省系统资源。</p><p>虽然断路器可以用一个状态变量在本地维护。但是如果你有一个<strong>分布式系统</strong>，你可能需要一个外部存储层。在多节点的配置中，应用服务器的状态需要在多个实例之间共享。在这种场景下，你可以使用 Redis、memcached 来记录外部服务的可用性。在向外部服务发送任何请求之前，从持久存储中查询服务的状态。</p><h2 id="分布式系统中的幂等性"><a href="#分布式系统中的幂等性" class="headerlink" title="分布式系统中的幂等性"></a>分布式系统中的幂等性</h2><p>幂等的服务是指客户端可以重复地发起相同的请求，并得到相同的最终结果。虽然服务器会对此操作产生相同的结果，但客户端不一定作出相同的反应。</p><p>对于 REST API 而言，你需要记住 ——</p><ul><li><strong>POST</strong> <strong>不是</strong>幂等的 —— POST 导致在服务器上创建新资源。n 个 POST 请求会在服务器上创建 n 个新的资源。</li><li><strong>GET</strong>、<strong>HEAD</strong>、<strong>OPTIONS</strong> 和 <strong>TRACE</strong> 方法<strong>永远</strong>不会改变服务器上资源的状态。因此，它们总是幂等的。</li><li><strong>PUT</strong> 请求是幂等的。n 个 PUT 请求会覆盖相同的资源 n-1 次。</li><li><strong>DELETE</strong> 是幂等的，因为它一开始会返回 200（OK），而后续的调用会返回 204（No Content）或 404（Not Found）。</li></ul><p><strong>为什么关注幂等操作呢？</strong></p><p>在分布式系统中，有多个服务器和客户端节点。如果你从客户端向服务器 A 发送了请求，请求失败或超时了，那么你想能够简单地再次发送该请求，而不必担心先前的请求是否有任何副作用。</p><p>这在微服务中是极其重要的，因为有很多独立工作的组件。</p><p>幂等性的一些主要好处有 ——</p><ul><li><strong>最小的复杂性</strong> —— 不需要担心副作用，可以简单地重试任何请求，并得到相同的最终结果。</li><li><strong>易于实现</strong> —— 你不需要添加逻辑来处理你的重试机制中先前失败的请求。</li><li><strong>易于测试</strong> —— 每个动作都会产生相同的结果，没有意外。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们梳理了一系列构建更容错系统的方法。然而，这些方法并不是全部。最后，我想指出几个供你查看的要点，或许能帮助提高你系统的可用性和容错性。</p><ul><li>在多节点配置中，如果一个客户端重试了多次，这些请求很可能到达同一个服务器。此时，最好返回一个失败的响应，让客户端从头重试。</li><li>对你的系统做性能统计，让它们时刻准备最坏的情况。你可以查看 <a href="https://github.com/Netflix/chaosmonkey" target="_blank" rel="noopener">Netflix 的 Chaos Monkey</a> —— 这是一个在系统中触发随机故障的弹性测试工具。这能让你为可能发生的故障做好准备，构建一个有弹性的系统。</li><li>如果你的系统由于某种原因处于过载状态，你可以尝试通过减载（load shedding）来分布负载。Google 做了一个很棒的<a href="https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons" target="_blank" rel="noopener">案例研究</a>，可以作为一个很好的起点。</li></ul><hr><p>一些资源：</p><ul><li><a href="https://www.dre.vanderbilt.edu/~schmidt/patterns-ace.html" target="_blank" rel="noopener">分布式系统中的模式</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry" target="_blank" rel="noopener">重试模式 - Microsoft</a></li><li><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">Martin Fowler - 断路器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在&lt;strong&gt;掘金翻译计划&lt;/strong&gt;中的译文。 译文链接：&lt;a href=&quot;https://juejin.im/post/5ccf98ace51d456e6d133541&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[译] 分布式系统如何从故障中恢复？— 重试、超时和退避&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://namc.in/2019-04-15-retries-timeouts-backoff&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Retries, Timeouts and Backoff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://namc.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/retries-timeouts-backoff.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/nettee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/fireairforce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fireairforce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;分布式系统很难。即使我们学了很多构建高可用性系统的方法，也常常会忽略系统设计中的弹性（resiliency）。&lt;/p&gt;
&lt;p&gt;我们肯定听说过容错性，但什么是“弹性”呢？个人而言，我喜欢将其定义为系统处理意外情况并最终从中恢复的能力。有很多方法使你的系统能从故障中回弹，但在这篇文章中，我们主要关注以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#超时&quot;&gt;超时&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#重试&quot;&gt;重试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#退避&quot;&gt;退避&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分布式系统中的幂等性&quot;&gt;分布式系统中的幂等性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;超时&quot;&gt;&lt;a href=&quot;#超时&quot; class=&quot;headerlink&quot; title=&quot;超时&quot;&gt;&lt;/a&gt;超时&lt;/h2&gt;&lt;p&gt;简单来说，超时就是两个连续的数据包之间的最大不活动时间。&lt;/p&gt;
&lt;p&gt;假设我们在某个时刻已经使用过了数据库驱动和 HTTP 客户端。所有帮助你的服务连接到一个外部服务器的客户端或驱动都有 Timeout 参数。这个参数通常默认为零或 -1，表示超时时间未定义，或是无限时间。&lt;/p&gt;
&lt;p&gt;例如：参考 &lt;code&gt;connectTimeout&lt;/code&gt; 和 &lt;code&gt;socketTimeout&lt;/code&gt; 的定义 &lt;a href=&quot;https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mysql Connector 配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数对外部服务器的请求都附有一个超时时间。当外部服务器没有及时响应时，超时的设置非常有必要。如果没有设置超时，并使用默认值 0/-1，你的程序可能会阻塞几分钟或更长的时间。这是因为，当你没有收到来自应用服务器的响应，并且你的超时时间无限或非常大时，这个连接会一直开着。随着有更多的请求到来，更多的连接会打开，并永远无法关闭。这会导致你的连接池耗尽，进而导致你的应用的故障。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用 Monkey 向 Android 设备精确发送事件</title>
    <link href="http://yoursite.com/posts/2019/Monkey-inject-events-with-Automated-Network-Control/"/>
    <id>http://yoursite.com/posts/2019/Monkey-inject-events-with-Automated-Network-Control/</id>
    <published>2019-03-20T16:35:01.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/studio/test/monkey" target="_blank" rel="noopener">Monkey</a> 是一个 Android 设备（模拟器或真实设备）上的一个程序，可以产生大量随机的用户输入事件，如点击、触摸、手势等。因此 Monkey 可用于 UI 上的压力测试。例如，下面的命令会启动一个特定的 app 并发送 500 个随机的事件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p your.package.name -v 500</span><br></pre></td></tr></table></figure><p>然而，Monkey 程序还有一个特殊的 <code>--port</code> 选项。当这个选项开启后，Monkey 会运行在 <em>Automated Network Control</em> 模式下，可以精确地向 app 发送一些 <a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noopener">KeyEvent</a> 和 <a href="https://developer.android.com/reference/android/view/MotionEvent" target="_blank" rel="noopener">MotionEvent</a>。这也提供了一种在 <code>adb shell input</code> 命令之外，程序性地发送用户事件的方法。关于 <code>adb shell input</code> 命令，可以参考<a href="https://stackoverflow.com/questions/7789826/adb-shell-input-events" target="_blank" rel="noopener">这里</a>。经测试，Monkey 支持的用户事件比 <code>input</code> 命令的用户事件更细致一些。例如 <code>input</code> 命令对 swipe 动作只能指定滑动时间，但 Monkey 可以细致地指定滑动中的多次手指移动。</p><p>如果你有 AOSP 源代码，可以在 <code>development/cmds/monkey/</code> 目录下找到 README.NETWORK.txt 文件，其中有说明 <em>Automated Network Control</em> 协议的简单文档。或者你可以访问<a href="https://android.googlesource.com/platform/development/+/master/cmds/monkey/README.NETWORK.txt" target="_blank" rel="noopener">这里</a>。</p><p>下面简单概括一下文档内容：</p><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p><code>monkey --port</code> 命令会让 monkey server 运行起来，并监听特定的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --port 1080</span><br></pre></td></tr></table></figure><p>那么我在 host 机器上就可以通过 TCP 连接来向 monkey server 发送命令。注意 monkey server 只会绑定 localhost。TCP 协议是 ADB 支持的，因此需要设置端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:1080 tcp:1080</span><br></pre></td></tr></table></figure><p>这样就可以向 monkey server 发送命令了。</p><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><p>不同的命令之间通过换行来分隔。对于正常完成的命令，monkey 会回复 OK；否则会回复 ERROR。如果命令有返回值，返回值会放在与 OK 或 ERROR 的同一行，以冒号分隔。ERROR 回复的返回值一般是错误消息。下面是一个请求-响应序列的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key down menu</span><br><span class="line">OK</span><br><span class="line">touch monkey</span><br><span class="line">ERROR: monkey not a number</span><br><span class="line">getvar sdk</span><br><span class="line">OK: donut</span><br><span class="line">getvar foo</span><br><span class="line">ERROR: no such var</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><h3 id="wake"><a href="#wake" class="headerlink" title="wake"></a>wake</h3><p>唤醒设备，以接收用户输入</p><h3 id="touch-down-up-move-x-y"><a href="#touch-down-up-move-x-y" class="headerlink" title="touch [down|up|move] x y"></a>touch [down|up|move] x y</h3><p>发送一个 <a href="https://developer.android.com/reference/android/view/MotionEvent" target="_blank" rel="noopener">MotionEvent</a>，模拟用户点击屏幕。x 和 y 是相对于左上角的坐标。如果要模拟滑动事件的话，可以先 touch down，然后 touch move，最后 touch up。</p><h3 id="tap-x-y"><a href="#tap-x-y" class="headerlink" title="tap x y"></a>tap x y</h3><p>是 touch 命令的简化版，相当于一次 touch down 和一次 touch up。</p><h3 id="key-down-up-keycode"><a href="#key-down-up-keycode" class="headerlink" title="key [down|up] keycode"></a>key [down|up] keycode</h3><p>发送一个 <a href="http://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noopener">KeyEvent</a>。keycode 既可以是文本也可以是整数值，例如 <code>KeyEvent.KEYCODE_MENU = 82</code>，那么发送 82 或者 “KEYCODE_MENU” 都可以。</p><h3 id="press-keycode"><a href="#press-keycode" class="headerlink" title="press keycode"></a>press keycode</h3><p>是 key 命令的简化版，相当于一次 key down 和一次 key up。</p><h3 id="type-string"><a href="#type-string" class="headerlink" title="type string"></a>type string</h3><p>模拟用户的键盘输入，通过生成 KeyEvent 来实现。</p><h3 id="flip-open-close"><a href="#flip-open-close" class="headerlink" title="flip [open|close]"></a>flip [open|close]</h3><p>模拟键盘的打开/关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/test/monkey&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Monkey&lt;/a&gt; 是一个 Android 设备（模拟器或真实设备）上的一个程序，可以产生大量随机的用户输入事件，如点击、触摸、手势等。因此 Monkey 可用于 UI 上的压力测试。例如，下面的命令会启动一个特定的 app 并发送 500 个随机的事件：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell monkey -p your.package.name -v 500&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，Monkey 程序还有一个特殊的 &lt;code&gt;--port&lt;/code&gt; 选项。当这个选项开启后，Monkey 会运行在 &lt;em&gt;Automated Network Control&lt;/em&gt; 模式下，可以精确地向 app 发送一些 &lt;a href=&quot;https://developer.android.com/reference/android/view/KeyEvent.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KeyEvent&lt;/a&gt; 和 &lt;a href=&quot;https://developer.android.com/reference/android/view/MotionEvent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MotionEvent&lt;/a&gt;。这也提供了一种在 &lt;code&gt;adb shell input&lt;/code&gt; 命令之外，程序性地发送用户事件的方法。关于 &lt;code&gt;adb shell input&lt;/code&gt; 命令，可以参考&lt;a href=&quot;https://stackoverflow.com/questions/7789826/adb-shell-input-events&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。经测试，Monkey 支持的用户事件比 &lt;code&gt;input&lt;/code&gt; 命令的用户事件更细致一些。例如 &lt;code&gt;input&lt;/code&gt; 命令对 swipe 动作只能指定滑动时间，但 Monkey 可以细致地指定滑动中的多次手指移动。&lt;/p&gt;
&lt;p&gt;如果你有 AOSP 源代码，可以在 &lt;code&gt;development/cmds/monkey/&lt;/code&gt; 目录下找到 README.NETWORK.txt 文件，其中有说明 &lt;em&gt;Automated Network Control&lt;/em&gt; 协议的简单文档。或者你可以访问&lt;a href=&quot;https://android.googlesource.com/platform/development/+/master/cmds/monkey/README.NETWORK.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面简单概括一下文档内容：&lt;/p&gt;
&lt;h2 id=&quot;建立连接&quot;&gt;&lt;a href=&quot;#建立连接&quot; class=&quot;headerlink&quot; title=&quot;建立连接&quot;&gt;&lt;/a&gt;建立连接&lt;/h2&gt;&lt;p&gt;&lt;code&gt;monkey --port&lt;/code&gt; 命令会让 monkey server 运行起来，并监听特定的端口：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell monkey --port 1080&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么我在 host 机器上就可以通过 TCP 连接来向 monkey server 发送命令。注意 monkey server 只会绑定 localhost。TCP 协议是 ADB 支持的，因此需要设置端口转发：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb forward tcp:1080 tcp:1080&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就可以向 monkey server 发送命令了。&lt;/p&gt;
&lt;h2 id=&quot;协议格式&quot;&gt;&lt;a href=&quot;#协议格式&quot; class=&quot;headerlink&quot; title=&quot;协议格式&quot;&gt;&lt;/a&gt;协议格式&lt;/h2&gt;&lt;p&gt;不同的命令之间通过换行来分隔。对于正常完成的命令，monkey 会回复 OK；否则会回复 ERROR。如果命令有返回值，返回值会放在与 OK 或 ERROR 的同一行，以冒号分隔。ERROR 回复的返回值一般是错误消息。下面是一个请求-响应序列的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;key down menu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;touch monkey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: monkey not a number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getvar sdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK: donut&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getvar foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: no such var&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记一次开源项目中使用 Git 犯错的经历</title>
    <link href="http://yoursite.com/posts/2019/A-mistake-on-Git-usage-in-an-open-source-project/"/>
    <id>http://yoursite.com/posts/2019/A-mistake-on-Git-usage-in-an-open-source-project/</id>
    <published>2019-03-03T15:07:27.000Z</published>
    <updated>2019-12-17T13:30:12.274Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>上参与翻译，这也是我第一次参与正式的开源项目。虽然这不是一个编程的项目，但也会使用 GitHub 的 issue / branch / pull request 这些工具来进行协作。我在一次更新分支的时候，push 了一些不必要的 commits。好在我仔细分析，然后在十分钟之内解决了问题。这是我第一次在正式的开源项目中遇到 Git 相关的挑战，想想也挺有趣的。在这里写篇文章记录一下。</p><p>首先介绍一下这个翻译项目的工作流程。项目的主分支是 master，当认领一篇文章进行翻译的时候，需要创建一个新分支 <code>translate/file-name.md</code>，翻译完成后需要创建一个 pull request 以供 review（也就是校对）。校对的主要过程是对 pull request 中内容进行评论。而校对之后，译者根据校对意见进行修改的时候，只需要直接提交到原分支，GitHub 就会自动将修改的内容同步到 pull request 中，非常方便。可以看到，整个项目其实和编程项目的工作方式类似，只不过你提交的不是源代码，而是翻译过的 markdown 文章。</p><h2 id="漫不经心的错误"><a href="#漫不经心的错误" class="headerlink" title="漫不经心的错误"></a>漫不经心的错误</h2><p>言归正传。我一共翻译了两篇文章，不妨称为 A 和 B。这样我就需要从 <code>master</code> 分支分出两个新分支：<code>translate/A.md</code> 和 <code>translate/B.md</code>。由于我两次翻译的间隔时间较短，<strong>在我创建分支 B 的时候，分支 A 还没有被 merge 到 master</strong>（这是重点）。也就是说，B 分支中的文件是没有我已翻译好的 A 文章的。</p><p>终于我的 B 文章也翻译完了，而且两位认真的校对者也在 pull request 中提出了自己的校对意见。我翻译文章 B 本来一直是在我的笔记本电脑上进行的。当我想要根据校对意见进行最后一次修改的时候，我突然决定直接在手边的台式机上干这些活！这当然是完全可以的，只是有点麻烦。我的台式机上有 <code>translate/A.md</code> 分支的所有内容，但很明显没有 <code>translate/B.md</code> 分支。于是我很自然地从 GitHub 上同步新的 B 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b translation/B.md</span><br><span class="line">git pull origin translation/B.md</span><br></pre></td></tr></table></figure><p>然而我犯了一个致命的错误，我本该从 master 分支上分出 B 分支的，但是我没有注意到当前分支是 A 分支。于是，<strong>我从 A 分支上分出了 B 分支</strong>！</p><a id="more"></a><p>这样，我的 B 分支中有了我翻译 A 文章时的几条 commit。Git 很贴心地为我 merge 了本地的 A 分支和 GitHub 上的 B 分支，然后跳出 vim 让我填写 <code>Merge ...</code> 开头的 commit 信息。我稀里糊涂地确认了。这样，我错过了一次意识到错误的机会。</p><p>很快我根据校对意见修改了几行内容。<code>git diff</code> 看一下，嗯没问题，于是直接 <code>git push origin translate/B.md</code> 完事。Git 开始上传，显示有 N 个 object 需要上传，以及跳动着上传进度……等等！我不是只修改了几行内容吗，怎么上传这么慢？好像有哪里不太对。</p><p>再打开 GitHub 上看一眼我的 pull request。天呐！<code>Commits</code> 飙升到了 12 个，<code>Files changed</code> 也变成了 2。仔细看看，我翻译 A 文章的 commit 全部都过来了！前面提到了，我创建 B 分支的时候，A 分支还没有被 merge 到 master。所以这里很不幸地，我的 B 分支被 A 分支里的 commit 给污染了。而且我 push 到了远程的分支上。</p><p>我以前也干过 Git 提交出错的问题。不过因为都是我的个人项目，我经常会干一些“直接删除 GitHub 仓库，再创建一个新的”这样粗暴的事情。不过现在这是一个公共的项目，而且分支对应的 pull request 里已经写满了两个人的校对意见！看来我必须要思考一些巧妙的解决方案了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案想出来之后，竟然意外地简单：我先用我的笔记本电脑（上面保存了原先正确的 B 分支）把 B 分支 force push 到 GitHub 上，再想办法补上我的最后一次修改。</p><p>第一步是 force push。这个操作我好像经常用。在 GitHub 上创建一个新的仓库的时候，有时候我会顺手创建一个 README。这样新的仓库就有一个 commit 了。我在本地已有的代码想 push 上去的时候，就会提示错误。于是我可以使用 force push 来覆盖掉 GitHub 上那个实际上没有内容的 README：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><p>放到这个情况下，就是我回到笔记本电脑上，强制覆盖掉远程（GitHub 上）的 <code>translate/B.md</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin tranlsate/B.md</span><br></pre></td></tr></table></figure><p>第二步，补上最后一次修改。本来我一开始想到的是用 cherry pick，但稳妥起见还是用了 diff 文件的方法，毕竟这个方法我比较熟悉。回到台式机上那个错误的 B 分支。首先把我最后一次 commit 的内容记录在 diff 文件里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~1 HEAD &gt; a.diff</span><br></pre></td></tr></table></figure><p>然后删除当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -D translate/B.md</span><br></pre></td></tr></table></figure><p>再重新同步新的分支（此时 GitHub 上已经是 force push 后的正确分支），把修改的内容加上去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b translate/B.md</span><br><span class="line">git pull origin translate/B.md</span><br><span class="line">git apply a.diff</span><br></pre></td></tr></table></figure><p>Good job! 终于化险为夷。我不禁感慨 Git 的强大。一方面，Git 的分布式特性，让你即使把服务器上的分支搞坏了，也能用本地的分支恢复。另一方面，Git 有强大的功能来让你修复自己的错误。这次我利用的是 git diff / git apply 功能。不过我对另外的高级功能如 git revert 和 git cherry-pick 还不是很熟。看来我还要再多学学 Git 的高级功能，以后如果捅出更大的篓子，也能有办法修补 XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;上参与翻译，这也是我第一次参与正式的开源项目。虽然这不是一个编程的项目，但也会使用 GitHub 的 issue / branch / pull request 这些工具来进行协作。我在一次更新分支的时候，push 了一些不必要的 commits。好在我仔细分析，然后在十分钟之内解决了问题。这是我第一次在正式的开源项目中遇到 Git 相关的挑战，想想也挺有趣的。在这里写篇文章记录一下。&lt;/p&gt;
&lt;p&gt;首先介绍一下这个翻译项目的工作流程。项目的主分支是 master，当认领一篇文章进行翻译的时候，需要创建一个新分支 &lt;code&gt;translate/file-name.md&lt;/code&gt;，翻译完成后需要创建一个 pull request 以供 review（也就是校对）。校对的主要过程是对 pull request 中内容进行评论。而校对之后，译者根据校对意见进行修改的时候，只需要直接提交到原分支，GitHub 就会自动将修改的内容同步到 pull request 中，非常方便。可以看到，整个项目其实和编程项目的工作方式类似，只不过你提交的不是源代码，而是翻译过的 markdown 文章。&lt;/p&gt;
&lt;h2 id=&quot;漫不经心的错误&quot;&gt;&lt;a href=&quot;#漫不经心的错误&quot; class=&quot;headerlink&quot; title=&quot;漫不经心的错误&quot;&gt;&lt;/a&gt;漫不经心的错误&lt;/h2&gt;&lt;p&gt;言归正传。我一共翻译了两篇文章，不妨称为 A 和 B。这样我就需要从 &lt;code&gt;master&lt;/code&gt; 分支分出两个新分支：&lt;code&gt;translate/A.md&lt;/code&gt; 和 &lt;code&gt;translate/B.md&lt;/code&gt;。由于我两次翻译的间隔时间较短，&lt;strong&gt;在我创建分支 B 的时候，分支 A 还没有被 merge 到 master&lt;/strong&gt;（这是重点）。也就是说，B 分支中的文件是没有我已翻译好的 A 文章的。&lt;/p&gt;
&lt;p&gt;终于我的 B 文章也翻译完了，而且两位认真的校对者也在 pull request 中提出了自己的校对意见。我翻译文章 B 本来一直是在我的笔记本电脑上进行的。当我想要根据校对意见进行最后一次修改的时候，我突然决定直接在手边的台式机上干这些活！这当然是完全可以的，只是有点麻烦。我的台式机上有 &lt;code&gt;translate/A.md&lt;/code&gt; 分支的所有内容，但很明显没有 &lt;code&gt;translate/B.md&lt;/code&gt; 分支。于是我很自然地从 GitHub 上同步新的 B 分支：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b translation/B.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull origin translation/B.md&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而我犯了一个致命的错误，我本该从 master 分支上分出 B 分支的，但是我没有注意到当前分支是 A 分支。于是，&lt;strong&gt;我从 A 分支上分出了 B 分支&lt;/strong&gt;！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>[译] 教程 - 用 C 写一个 Shell</title>
    <link href="http://yoursite.com/posts/2019/Tutorial-Write-a-Shell-in-C/"/>
    <id>http://yoursite.com/posts/2019/Tutorial-Write-a-Shell-in-C/</id>
    <published>2019-02-25T20:32:18.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在<strong>掘金翻译计划</strong>中的译文。 译文链接：<a href="https://juejin.im/post/5c73dd7d6fb9a049aa6fb9aa" target="_blank" rel="noopener">[译] 教程 - 用 C 写一个 Shell</a></p><ul><li>原文地址：<a href="https://brennan.io/2015/01/16/write-a-shell-in-c/" target="_blank" rel="noopener">Tutorial - Write a Shell in C</a></li><li>原文作者：<a href="https://brennan.io" target="_blank" rel="noopener">Stephen Brennan</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/tutorial-write-a-shell-in-c.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/tutorial-write-a-shell-in-c.md</a></li><li>译者：<a href="https://github.com/nettee" target="_blank" rel="noopener">nettee</a></li><li>校对者：<a href="https://github.com/kasheemlew" target="_blank" rel="noopener">kasheemlew</a>，<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li></ul><hr><p>你很容易认为自己“不是一个<strong>真正的</strong>程序员”。有一些程序所有人都用，它们的开发者很容易被捧上神坛。虽然开发大型软件项目并不容易，但很多时候这种软件的基本思想都很简单。自己实现这样的软件是一种证明自己可以是真正的程序员的有趣方式。所以，这篇文章介绍了我是如何用 C 语言写一个自己的简易 Unix shell 的。我希望其他人也能感受到这种有趣的方式。</p><p>这篇文章中介绍的 shell（叫做 <code>lsh</code>），可以在 <a href="https://github.com/brenns10/lsh" target="_blank" rel="noopener">GitHub</a> 上获取它的源代码。</p><p><strong>学校里的学生请注意！</strong> 许多课程都有要求你编写一个 shell 的作业，而且有些教师都知道这样的教程和代码。如果你是此类课程上的学生，请不要在未经允许的情况下复制（或复制加修改）这里的代码。我<a href="https://brennan.io/2016/03/29/dishonesty/" target="_blank" rel="noopener">建议</a>反对重度依赖本教程的行为。</p><h3 id="Shell-的基本生命周期"><a href="#Shell-的基本生命周期" class="headerlink" title="Shell 的基本生命周期"></a>Shell 的基本生命周期</h3><p>让我们自顶向下地观察一个 shell。一个 shell 在它的生命周期中主要做三件事。</p><ul><li><strong>初始化</strong>：在这一步中，shell 一般会加载并执行它的配置文件。这些配置会改变 shell 的行为。</li><li><strong>解释执行</strong>：接着，shell 会从标准输入（可能是交互式输入，也可能是一个文件）读取命令，并执行这些命令。</li><li><strong>终止</strong>：当命令全部执行完毕，shell 会执行关闭命令，释放所有内存，然后终止。</li></ul><a id="more"></a><p>这三个步骤过于宽泛，其实可以适用于任何程序，但我们可以将其用于我们的 shell 的基础。我们的 shell 会很简单，不需要任何配置文件，也没有任何关闭命令。那么，我们只需要调用循环函数，然后终止。不过对于架构而言，我们需要记住，程序的生命周期并不仅仅是循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果有配置文件，则加载。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行命令循环</span></span><br><span class="line">  lsh_loop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做一些关闭和清理工作。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里你可以看到，我只是写了一个函数：<code>lsh_loop()</code>。这个函数会循环，并解释执行一条条命令。我们接下来会看到这个循环如何实现。</p><h3 id="Shell-的基本循环"><a href="#Shell-的基本循环" class="headerlink" title="Shell 的基本循环"></a>Shell 的基本循环</h3><p>我们已经知道了 shell 程序如何启动。现在考虑程序的基本逻辑：shell 在它的循环中会做什么？处理命令的一个简单的方式是采用这三步：</p><ul><li><strong>读取</strong>：从标准输入读取一个命令。</li><li><strong>分析</strong>：将命令字符串分割为程序名和参数。</li><li><strong>执行</strong>：运行分析后的命令。</li></ul><p>下面，我将这些思路转化为 <code>lsh_loop()</code> 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh_loop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *line;</span><br><span class="line">  <span class="keyword">char</span> **args;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">    line = lsh_read_line();</span><br><span class="line">    args = lsh_split_line(line);</span><br><span class="line">    status = lsh_execute(args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">free</span>(args);</span><br><span class="line">  &#125; <span class="keyword">while</span> (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看一遍这段代码。一开始的几行只是一些声明。Do-while 循环在检查状态变量时会更方便，因为它会在检查变量的值之前先执行一次。在循环内部，我们打印了一个提示符，调用函数来分别读取一行输入、将一行分割为参数，以及执行这些参数。最后，我们释放之前为 line 和 args 申请的内存空间。注意到我们使用 <code>lsh_execute()</code> 返回的状态变量决定何时退出循环。</p><h3 id="读取一行输入"><a href="#读取一行输入" class="headerlink" title="读取一行输入"></a>读取一行输入</h3><p>从标准输入读取一行听起来很简单，但用 C 语言做起来可能有一定难度。坏消息是，你没法预先知道用户会在 shell 中键入多长的文本。因此你不能简单地分配一块空间，希望能装得下用户的输入，而应该先暂时分配一定长度的空间，当确实装不下用户的输入时，再重新分配更多的空间。这是 C 语言中的一个常见策略，我们也会用这个方法来实现 <code>lsh_read_line()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSH_RL_BUFSIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">lsh_read_line</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bufsize = LSH_RL_BUFSIZE;</span><br><span class="line">  <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * bufsize);</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lsh: allocation error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 读一个字符</span></span><br><span class="line">    c = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们到达了 EOF, 就将其替换为 '\0' 并返回。</span></span><br><span class="line">    <span class="keyword">if</span> (c == EOF || c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">      buffer[position] = <span class="string">'\0'</span>;</span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[position] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    position++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们超出了 buffer 的大小，则重新分配。</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= bufsize) &#123;</span><br><span class="line">      bufsize += LSH_RL_BUFSIZE;</span><br><span class="line">      buffer = <span class="built_in">realloc</span>(buffer, bufsize);</span><br><span class="line">      <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lsh: allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分是很多的声明。也许你没有发现，我倾向于使用古老的 C 语言风格，将变量的声明放在其他代码前面。这个函数的重点在（显然是无限的）<code>while (1)</code> 循环中。在这个循环中，我们读取了一个字符（并将它保存为 <code>int</code> 类型，而不是 <code>char</code> 类型，这很重要！EOF 是一个整型值而不是字符型值。如果你想将它的值作为判断条件，需要使用 <code>int</code> 类型。这是 C 语言初学者常犯的错误。）。如果这个字符是换行符或者 EOF，我们将当前字符串用空字符结尾，并返回它。否则，我们将这个字符添加到当前的字符串中。</p><p>下一步，我们检查下一个字符是否会超出当前的缓冲区大小。如果会超出，我们就先重新分配缓冲区（并检查内存分配是否成功）。就是这样。</p><p>如果你对新版的 C 标准库很熟悉，会注意到 <code>stdio.h</code> 中有一个 <code>getline()</code> 函数，和我们刚才实现的功能几乎一样。实话说，我在写完上面这段代码之后才知道这个函数的存在。这个函数一直是 C 标准库的 GNU 扩展，直到 2008 年才加入规约中，大多数现代的 Unix 系统应该都已经有了这个函数。我会保持我已写的代码，我也鼓励你们先用这种方式学习，然后再使用 <code>getline</code>。否则，你会失去一次学习的机会！不管怎样，有了 <code>getline</code> 之后，这个函数就不重要了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">lsh_read_line</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">ssize_t</span> bufsize = <span class="number">0</span>; <span class="comment">// 利用 getline 帮助我们分配缓冲区</span></span><br><span class="line">  getline(&amp;line, &amp;bufsize, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析一行输入"><a href="#分析一行输入" class="headerlink" title="分析一行输入"></a>分析一行输入</h3><p>好，那我们回到最初的那个循环。我们目前实现了 <code>lsh_read_line()</code>，得到了一行输入。现在，我们需要将这一行解析为参数的列表。我在这里将会做一个巨大的简化，假设我们的命令行参数中不允许使用引号和反斜杠转义，而是简单地使用空白字符作为参数间的分隔。这样的话，命令 <code>echo &quot;this message&quot;</code> 就不是使用单个参数 <code>this message</code> 调用 echo，而是有两个参数： <code>&quot;this</code> 和 <code>message&quot;</code>。</p><p>有了这些简化，我们需要做的只是使用空白符作为分隔符标记字符串。这意味着我们可以使用传统的库函数 <code>strtok</code> 来为我们干些苦力活。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSH_TOK_BUFSIZE 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSH_TOK_DELIM <span class="meta-string">" \t\r\n\a"</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">lsh_split_line</span><span class="params">(<span class="keyword">char</span> *line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bufsize = LSH_TOK_BUFSIZE, position = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> **tokens = <span class="built_in">malloc</span>(bufsize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">  <span class="keyword">char</span> *token;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tokens) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lsh: allocation error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  token = strtok(line, LSH_TOK_DELIM);</span><br><span class="line">  <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    tokens[position] = token;</span><br><span class="line">    position++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= bufsize) &#123;</span><br><span class="line">      bufsize += LSH_TOK_BUFSIZE;</span><br><span class="line">      tokens = <span class="built_in">realloc</span>(tokens, bufsize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">      <span class="keyword">if</span> (!tokens) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lsh: allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = strtok(<span class="literal">NULL</span>, LSH_TOK_DELIM);</span><br><span class="line">  &#125;</span><br><span class="line">  tokens[position] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来和 <code>lsh_read_line()</code> 极其相似。这是因为它们就是很相似！我们使用了相同的策略 —— 使用一个缓冲区，并且将其动态地扩展。不过这里我们使用的是以空指针结尾的指针数组，而不是以空字符结尾的字符数组。</p><p>在函数的开始处，我们开始调用 <code>strtok</code> 来分割 token。这个函数会返回指向第一个 token 的指针。<code>strtok()</code> 实际上做的是返回指向你传入的字符串内部的指针，并在每个 token 的结尾处放置字节 <code>\0</code>。我们将每个返回的指针放在一个字符指针的数组（缓冲区）中。</p><p>最后，我们在必要时重新分配指针数组。这样的处理过程一直重复，直到 <code>strtok</code> 不再返回 token 为止。此时，我们将 token 列表的尾部设为空指针。</p><p>这样，我们的工作完成了，我们得到了 token 的数组。接下来我们就可以执行命令。那么问题来了，我们怎么去执行命令呢？</p><h3 id="Shell-如何启动进程"><a href="#Shell-如何启动进程" class="headerlink" title="Shell 如何启动进程"></a>Shell 如何启动进程</h3><p>现在，我们真正来到了 shell 的核心位置。Shell 的主要功能就是启动进程。所以写一个 shell 意味着你要很清楚进程中发生了什么，以及进程是如何启动的。因此这里我要暂时岔开话题，聊一聊 Unix 中的进程。</p><p>在 Unix 中，启动进程只有两种方式。第一种（其实不能算一种方式）是成为 Init 进程。当 Unix 机器启动时，它的内核会被加载。内核加载并初始化完成后，会启动单独一个进程，叫做 Init 进程。这个进程在机器开启的时间中会一直运行，负责管理启动其他的你需要的进程，这样机器才能正常使用。</p><p>既然大部分的程序都不是 Init，那么实际上就只有一种方式启动进程：使用 <code>fork()</code> 系统调用。当调用该函数时，操作系统会将当前进程复制一份，并让两者同时运行。原有的进程叫做“父进程”，而新的进程叫做“子进程”。<code>fork()</code> 会在子进程中返回 0，在父进程中返回子进程的进程 ID 号（PID）。本质上，这意味着新进程启动的唯一方法是复制一个已有的进程。</p><p>这看上去好像有点问题。特别是，当你想运行一个新的进程时，你肯定不希望再运行一遍相同的程序 —— 你想运行的是另一个程序。这就是 <code>exec()</code> 系统调用所做的事情。它会将当前运行的程序替换为一个全新的程序。这意味着每当你调用 <code>exec</code>，操作系统都会停下你的进程，加载新的程序，然后在原处启动新的程序。一个进程从来不会从 <code>exec()</code> 调用中返回（除非出现错误）。</p><p>有了这两个系统调用，我们就有了大多数程序在 Unix 上运行的基本要素。首先，一个已有的进程将自己分叉（fork）为两个不同的进程。然后，子进程使用 <code>exec()</code> 将自己正在执行的程序替换为一个新的程序。父进程可以继续做其他的事情，甚至也可以使用系统调用 <code>wait()</code> 继续关注子进程。</p><p>啊！我们讲了这么多。但是有了这些作为背景，下面启动程序的代码才是说得通的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_launch</span><span class="params">(<span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> (execvp(args[<span class="number">0</span>], args) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">"lsh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fork 出错</span></span><br><span class="line">    perror(<span class="string">"lsh"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数使用了我们之前创建的参数列表。然后，它 fork 当前的进程，并保存返回值。当 <code>fork()</code> 返回时，我们实际上有了<strong>两个</strong>并发运行的进程。子进程会进入第一个 if 分支（<code>pid == 0</code>）。</p><p>在子进程中，我们想要运行用户提供的命令。所以，我们使用 <code>exec</code> 系统调用的多个变体之一：<code>execvp</code>。<code>exec</code> 的不同变体做的事情稍有不同。一些接受变长的字符串参数，一些接受字符串的列表，还有一些允许你设定进程运行的环境。<code>execvp</code> 这个变体接受一个程序名和一个字符串参数的数组（也叫做向量（vector），因此是‘v’）（数组的第一个元素应当是程序名）。‘p’ 表示我们不需要提供程序的文件路径，只需要提供文件名，让操作系统搜索程序文件的路径。</p><p>如果 exec 命令返回 -1（或者说，如果它返回了），我们就知道有地方出错了。那么，我们使用 <code>perror</code> 打印系统的错误消息以及我们的程序名，让用户知道是哪里出了错。然后，我们让 shell 继续运行。</p><p>第二个 if 条件（<code>pid &lt; 0</code>）检查 <code>fork()</code> 是否出错。如果出错，我们打印错误，然后继续执行 —— 除了告知用户，我们不会进行更多的错误处理。我们让用户决定是否需要退出。</p><p>第三个 if 条件表明 <code>fork()</code> 成功执行。父进程会运行到这里。我们知道子进程会执行命令的进程，所以父进程需要等待命令运行结束。我们使用 <code>waitpid()</code> 来等待一个进程改变状态。不幸的是，<code>waitpid()</code> 有很多选项（就像 <code>exec()</code> 一样）。进程可以以很多种方式改变其状态，并不是所有的状态都表示进程结束。一个进程可能退出（正常退出，或者返回一个错误码），也可能被一个信号终止。所以，我们需要使用 <code>waitpid()</code> 提供的宏来等待进程退出或被终止。函数最终返回 1，提示上层函数需要继续提示用户输入了。</p><h3 id="Shell-内置函数"><a href="#Shell-内置函数" class="headerlink" title="Shell 内置函数"></a>Shell 内置函数</h3><p>你可能发现了，<code>lsh_loop()</code> 函数调用了 <code>lsh_execute()</code>。但上面我们写的函数却叫做 <code>lsh_launch()</code>。这是有意为之的。虽然 shell 执行的命令大部分是程序，但有一些不是。一些命令是 shell 内置的。</p><p>这里的原因其实很简单。如果你想改变当前目录，你需要使用函数 <code>chdir()</code>。问题是，当前目录是进程的一个属性。那么，如果你写了一个叫 <code>cd</code> 的程序来改变当前目录，它只会改变自己当前的目录，然后终止。它的父进程的当前目录不会改变。所以应当是 shell 进程自己执行 <code>chdir()</code>，才能更新自己的当前目录。然后，当它启动子进程时，子进程也会继承这个新的目录。</p><p>类似的，如果有一个程序叫做 <code>exit</code>，它也没有办法使调用它的 shell 退出。这个命令也必须内置在 shell 中。还有，多数 shell 通过运行配置脚本（如 <code>~/.bashrc</code>）来进行配置。这些脚本使用一些改变 shell 行为的命令。这些命令如果由 shell 自己实现的话，同样只会改变 shell 自己的行为。</p><p>因此，我们需要向 shell 本身添加一些命令是有道理的。我添加进我的 shell 的命令是 <code>cd</code>、<code>exit</code> 和 <code>help</code>。下面是他们的函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  内置 shell 命令的函数声明：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_cd</span><span class="params">(<span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_help</span><span class="params">(<span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_exit</span><span class="params">(<span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  内置命令列表，以及它们对应的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> *builtin_str[] = &#123;</span><br><span class="line">  <span class="string">"cd"</span>,</span><br><span class="line">  <span class="string">"help"</span>,</span><br><span class="line">  <span class="string">"exit"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*builtin_func[]) (<span class="keyword">char</span> **) = &#123;</span><br><span class="line">  &amp;lsh_cd,</span><br><span class="line">  &amp;lsh_help,</span><br><span class="line">  &amp;lsh_exit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_num_builtins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(builtin_str) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  内置命令的函数实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_cd</span><span class="params">(<span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lsh: expected argument to \"cd\"\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chdir(args[<span class="number">1</span>]) != <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"lsh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_help</span><span class="params">(<span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stephen Brennan's LSH\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Type program names and arguments, and hit enter.\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The following are built in:\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lsh_num_builtins(); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, builtin_str[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Use the man command for information on other programs.\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_exit</span><span class="params">(<span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有三个部分。第一部分包括我的函数的<strong>前置声明</strong>。前置声明是当你声明了（但还未定义）某个符号，就可以在它的定义之前使用。我这么做是因为 <code>lsh_help()</code> 使用了内置命令的数组，而这个数组中又包括 <code>lsh_help()</code>。打破这个依赖循环的最好方式是使用前置声明。</p><p>第二个部分是内置命令名字的数组，然后是它们对应的函数的数组。这样做是为了，在未来可以简单地通过修改这些数组来添加内置命令，而不是修改代码中某处一个庞大的“switch”语句。如果你不理解 <code>builtin_func</code> 的声明，这很正常！我也不理解。这是一个函数指针（一个接受字符串数组作为参数，返回整型的函数）的数组。C 语言中任何有关函数指针的声明都会很复杂。我自己仍然需要查一下函数指针是怎么声明的！</p><p>最后，我实现了每个函数。<code>lsh_cd()</code> 函数首先检查它的第二个参数是否存在，不存在的话打印错误消息。然后，它调用 <code>chdir()</code>，检查是否出错，并返回。帮助函数会打印漂亮的消息，以及所有内置函数的名字。退出函数返回 0，这是让命令循环退出的信号。</p><h3 id="组合内置命令与进程"><a href="#组合内置命令与进程" class="headerlink" title="组合内置命令与进程"></a>组合内置命令与进程</h3><p>我们的程序最后缺失的一部分就是实现 <code>lsh_execute()</code> 了。这个函数要么启动一个内置命令，要么启动一个进程。如果你一路读到了这里，你会知道我们只剩下一个非常简单的函数需要实现了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsh_execute</span><span class="params">(<span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 用户输入了一个空命令</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lsh_num_builtins(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(args[<span class="number">0</span>], builtin_str[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (*builtin_func[i])(args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lsh_launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数所做的不过是检查命令是否和各个内置命令相同，如果相同的话就运行内置命令。如果没有匹配到一个内置命令，我们会调用 <code>lsh_launch()</code> 来启动进程。需要注意的是，有可能用户输入了一个空字符串或字符串只有空白符，此时 <code>args</code> 只包含空指针。所以，我们需要在一开始检查这种情况。</p><h3 id="全部组合在一起"><a href="#全部组合在一起" class="headerlink" title="全部组合在一起"></a>全部组合在一起</h3><p>以上就是这个 shell 的全部代码了。如果你已经读完，你应该完全理解了 shell 是如何工作的。要试用它（在 Linux 机器上）的话，你需要将这些代码片段复制到一个文件中（<code>main.c</code>），然后编译它。确保代码中只包括一个 <code>lsh_read_line()</code> 的实现。你需要在文件的顶部包含以下的头文件。我添加了注释，以便你知道每个函数的来源。</p><ul><li><code>#include &lt;sys/wait.h&gt;</code><ul><li><code>waitpid()</code> 及其相关的宏</li></ul></li><li><code>#include &lt;unistd.h&gt;</code><ul><li><code>chdir()</code></li><li><code>fork()</code></li><li><code>exec()</code></li><li><code>pid_t</code></li></ul></li><li><code>#include &lt;stdlib.h&gt;</code><ul><li><code>malloc()</code></li><li><code>realloc()</code></li><li><code>free()</code></li><li><code>exit()</code></li><li><code>execvp()</code></li><li><code>EXIT_SUCCESS</code>, <code>EXIT_FAILURE</code></li></ul></li><li><code>#include &lt;stdio.h&gt;</code><ul><li><code>fprintf()</code></li><li><code>printf()</code></li><li><code>stderr</code></li><li><code>getchar()</code></li><li><code>perror()</code></li></ul></li><li><code>#include &lt;string.h&gt;</code><ul><li><code>strcmp()</code></li><li><code>strtok()</code></li></ul></li></ul><p>当你准备好了代码和头文件，简单地运行 <code>gcc -o main main.c</code> 进行编译，然后 <code>./main</code> 来运行即可。</p><p>或者，你可以从 <a href="https://github.com/brenns10/lsh/tree/407938170e8b40d231781576e05282a41634848c" target="_blank" rel="noopener">GitHub</a> 上获取代码。这个链接直接跳转到我写这篇文章时的代码当前版本 —— 未来我可能会更新代码，增加一些新的功能。如果代码更新了，我会尽量在本文中更新代码的细节和实现思路。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如果你读了这篇文章，想知道我到底是怎么知道如何使用这些系统调用的。答案很简单：通过手册页（man pages）。在 <code>man 3p</code> 中有对每个系统调用的详尽文档。如果你知道你要找什么，只是想知道如何使用它，那么手册页是你最好的朋友。如果你不知道 C 标准库和 Unix 为你提供了什么样的接口，我推荐你阅读 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/" target="_blank" rel="noopener">POSIX 规范</a>，特别是第 13 章，“头文件”。你可以找到每个头文件，以及其中需要定义哪些内容。</p><p>显然，这个 shell 的功能不够丰富。一些明显的遗漏有：</p><ul><li>只用了空白符分割参数，没有考虑到引号和反斜杠转义。</li><li>没有管道和重定向。</li><li>内置命令太少。</li><li>没有通配符。</li></ul><p>实现这几个功能其实非常有趣，但已经远不是我这样一篇文章可以容纳的了的了。如果我开始实现其中任何一项，我一定会写一篇关于它的后续文章。不过我鼓励读者们都尝试自己实现这些功能。如果你成功了，请在下面的评论区给我留言，我很乐意看到你的代码。</p><p>最后，感谢阅读这篇教程（如果有人读了的话）。我写得很开心，也希望你能读得开心。在评论区让我知道你的想法！</p><p><strong>更新：</strong> 在本文的较早版本中，我在 <code>lsh_split_line()</code> 中遇到了一些讨厌的 bug，它们恰好相互抵消了。感谢 Reddit 的 /u/munmap（以及其他评论者）找到了这些 bug！ 在<a href="https://github.com/brenns10/lsh/commit/486ec6dcdd1e11c6dc82f482acda49ed18be11b5" target="_blank" rel="noopener">这里</a>看看我究竟做错了什么。</p><p><strong>更新二：</strong> 感谢 GitHub 用户 ghswa 贡献了我忘记的一些 <code>malloc()</code> 的空指针检查。他/她还指出 <code>getline</code> 的<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html" target="_blank" rel="noopener">手册页</a>规定了第一个参数所占用的内存空间应当可以被释放，所以我的使用 <code>getline()</code> 的 <code>lsh_read_line()</code> 实现中，<code>line</code> 应当初始化为 <code>NULL</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在&lt;strong&gt;掘金翻译计划&lt;/strong&gt;中的译文。 译文链接：&lt;a href=&quot;https://juejin.im/post/5c73dd7d6fb9a049aa6fb9aa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[译] 教程 - 用 C 写一个 Shell&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://brennan.io/2015/01/16/write-a-shell-in-c/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tutorial - Write a Shell in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://brennan.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stephen Brennan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/tutorial-write-a-shell-in-c.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/tutorial-write-a-shell-in-c.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/nettee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/kasheemlew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kasheemlew&lt;/a&gt;，&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;你很容易认为自己“不是一个&lt;strong&gt;真正的&lt;/strong&gt;程序员”。有一些程序所有人都用，它们的开发者很容易被捧上神坛。虽然开发大型软件项目并不容易，但很多时候这种软件的基本思想都很简单。自己实现这样的软件是一种证明自己可以是真正的程序员的有趣方式。所以，这篇文章介绍了我是如何用 C 语言写一个自己的简易 Unix shell 的。我希望其他人也能感受到这种有趣的方式。&lt;/p&gt;
&lt;p&gt;这篇文章中介绍的 shell（叫做 &lt;code&gt;lsh&lt;/code&gt;），可以在 &lt;a href=&quot;https://github.com/brenns10/lsh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 上获取它的源代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学校里的学生请注意！&lt;/strong&gt; 许多课程都有要求你编写一个 shell 的作业，而且有些教师都知道这样的教程和代码。如果你是此类课程上的学生，请不要在未经允许的情况下复制（或复制加修改）这里的代码。我&lt;a href=&quot;https://brennan.io/2016/03/29/dishonesty/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议&lt;/a&gt;反对重度依赖本教程的行为。&lt;/p&gt;
&lt;h3 id=&quot;Shell-的基本生命周期&quot;&gt;&lt;a href=&quot;#Shell-的基本生命周期&quot; class=&quot;headerlink&quot; title=&quot;Shell 的基本生命周期&quot;&gt;&lt;/a&gt;Shell 的基本生命周期&lt;/h3&gt;&lt;p&gt;让我们自顶向下地观察一个 shell。一个 shell 在它的生命周期中主要做三件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：在这一步中，shell 一般会加载并执行它的配置文件。这些配置会改变 shell 的行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解释执行&lt;/strong&gt;：接着，shell 会从标准输入（可能是交互式输入，也可能是一个文件）读取命令，并执行这些命令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止&lt;/strong&gt;：当命令全部执行完毕，shell 会执行关闭命令，释放所有内存，然后终止。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java 8： 事实上的多继承语言</title>
    <link href="http://yoursite.com/posts/2018/Java-8-default-Method-and-Multiple-Inheritance/"/>
    <id>http://yoursite.com/posts/2018/Java-8-default-Method-and-Multiple-Inheritance/</id>
    <published>2018-12-26T20:38:57.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java 在多重继承上的设计甚至不如 C++</strong>。这个论点让人很难接受，毕竟我们在第一堂 Java 课上学到了：“Java 的优越性之一是摒除了 C++ 中易出错的多重继承”。然而，Java 的类单继承、接口多继承的设计，最终使 Java 走上了多重继承的老路，这最后一根稻草就是 Java 8 的 <code>default</code> 关键字。</p><h2 id="Java-为什么设计成单继承"><a href="#Java-为什么设计成单继承" class="headerlink" title="Java 为什么设计成单继承"></a>Java 为什么设计成单继承</h2><p>Java 语言在设计之初显然受到了 C++ 的很大影响。然而，Java 最终却没有采用 C++ 的多重继承方案。这是 Java 与 C++ 区分开的一个特点。在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现，这就避免了 C++ 中多继承的决议问题。</p><p>James Gosling 在设计 Java 的继承方案时，借鉴了 Objective-C 中的“纯接口”概念。他发现，没有实现体的纯接口避免了 C++ 中的很多歧义和坑。因此 Java 引入了 interface。</p><h2 id="Java-8：default-关键字的引入"><a href="#Java-8：default-关键字的引入" class="headerlink" title="Java 8：default 关键字的引入"></a>Java 8：default 关键字的引入</h2><p>Java 8 这一版本可以说是 Java 5 之后一次最大的改动了。在全面引入了 lambda 和函数式编程之后，JDK 中的很多接口也需要升级，例如 <code>Iterable.forEach</code>:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">     Iterator&lt;T&gt; iterator();</span><br><span class="line"><span class="addition">+    void forEach(Consumer&lt;? super T&gt; action);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然而，如果直接在 <code>Iterable</code> 接口中添加 <code>forEach</code> 方法。在 Java 7 及以前的所有实现 <code>Iterable</code> 的类都无法通过编译。为了向后兼容已有的代码，Java 8 引入了 <code>default</code> 关键字以及 default method，用来在接口中定义一个有方法体的方法。通过定义一个 default 的 <code>forEach</code>。所有实现了 <code>Iterable</code> 的类无需修改代码，便可在对象上调用 <code>forEach</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="default-与多重继承"><a href="#default-与多重继承" class="headerlink" title="default 与多重继承"></a>default 与多重继承</h2><a id="more"></a><p>Java 在设计之初，将 interface 设计成“没有任何实现”的纯接口，以此来避免接口多继承可能导致的问题。如果继承的多个接口中定义了相同的方法，只需要检查方法的返回值是否一致即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>, <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 编译器检查 Foo 和 Bar 中的 doSomething() 返回类型是否相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在引入了 default method 之后，情况变得不太一样了。子接口可以 override 父接口定义的方法。我们可以轻易地构造出 C++ 的多重继承常出现的“<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">菱形问题</a>”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Foo::doSomething"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Bar::doSomething"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>, <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error: inherit unrelated default from super-interfaces</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>Foo</code> 和 <code>Bar</code> 都重写了 <code>doSomething</code>，使得 <code>FooBar</code> 中的 <code>doSomething</code> 的含义出现了歧义，编译器会在此处报错。</p><h2 id="Interface-还是-interface-吗"><a href="#Interface-还是-interface-吗" class="headerlink" title="Interface 还是 interface 吗"></a>Interface 还是 interface 吗</h2><p>Java 8 引入的 default method 当然是一次对 interface 的极大增强（同时引入的还有 static method）。但是我们不禁思考，现在的 interface 是否还是 Java 设计之初的那个“纯接口”。上面的菱形问题的例子，我们发现，带有 default method 的接口表现得和抽象类越来越相似了。当然，interface 无法拥有和抽象类一样的能力，例如没有 private 的 method 和 field。但是以 interface 目前的能力，已经足够导致菱形问题这样的多继承问题。</p><p>在 Java 9 中，为了解决 default method 中重复代码的例子，又为 interface 引入了 private method （以及 private static method），interface 的能力进一步得到增强。可以预料，未来 Java 中接口的能力将无限接近于抽象类。从这个层面上来讲，Java 虽然当年努力与 C++ 区分开，可还是和 C++ 越来越像。</p><p>多继承当然是一种有力的语言机制，库和框架的开发者应该可以使用多继承实现一些酷炫的功能。但对于普通的 Java 程序员来说，interface 的语义变化会带来额外的心智负担。所以最好的办法是，忘记 default method 这件事情，让 interface 继续做最纯粹的接口。多继承这件事情，还是交给 Scala 这样更现代的语言来写吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java 在多重继承上的设计甚至不如 C++&lt;/strong&gt;。这个论点让人很难接受，毕竟我们在第一堂 Java 课上学到了：“Java 的优越性之一是摒除了 C++ 中易出错的多重继承”。然而，Java 的类单继承、接口多继承的设计，最终使 Java 走上了多重继承的老路，这最后一根稻草就是 Java 8 的 &lt;code&gt;default&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;h2 id=&quot;Java-为什么设计成单继承&quot;&gt;&lt;a href=&quot;#Java-为什么设计成单继承&quot; class=&quot;headerlink&quot; title=&quot;Java 为什么设计成单继承&quot;&gt;&lt;/a&gt;Java 为什么设计成单继承&lt;/h2&gt;&lt;p&gt;Java 语言在设计之初显然受到了 C++ 的很大影响。然而，Java 最终却没有采用 C++ 的多重继承方案。这是 Java 与 C++ 区分开的一个特点。在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现，这就避免了 C++ 中多继承的决议问题。&lt;/p&gt;
&lt;p&gt;James Gosling 在设计 Java 的继承方案时，借鉴了 Objective-C 中的“纯接口”概念。他发现，没有实现体的纯接口避免了 C++ 中的很多歧义和坑。因此 Java 引入了 interface。&lt;/p&gt;
&lt;h2 id=&quot;Java-8：default-关键字的引入&quot;&gt;&lt;a href=&quot;#Java-8：default-关键字的引入&quot; class=&quot;headerlink&quot; title=&quot;Java 8：default 关键字的引入&quot;&gt;&lt;/a&gt;Java 8：default 关键字的引入&lt;/h2&gt;&lt;p&gt;Java 8 这一版本可以说是 Java 5 之后一次最大的改动了。在全面引入了 lambda 和函数式编程之后，JDK 中的很多接口也需要升级，例如 &lt;code&gt;Iterable.forEach&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; public interface Iterable&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Iterator&amp;lt;T&amp;gt; iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;addition&quot;&gt;+    void forEach(Consumer&amp;lt;? super T&amp;gt; action);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，如果直接在 &lt;code&gt;Iterable&lt;/code&gt; 接口中添加 &lt;code&gt;forEach&lt;/code&gt; 方法。在 Java 7 及以前的所有实现 &lt;code&gt;Iterable&lt;/code&gt; 的类都无法通过编译。为了向后兼容已有的代码，Java 8 引入了 &lt;code&gt;default&lt;/code&gt; 关键字以及 default method，用来在接口中定义一个有方法体的方法。通过定义一个 default 的 &lt;code&gt;forEach&lt;/code&gt;。所有实现了 &lt;code&gt;Iterable&lt;/code&gt; 的类无需修改代码，便可在对象上调用 &lt;code&gt;forEach&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Iterator&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Consumer&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Objects.requireNonNull(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (T t : &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            action.accept(t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;default-与多重继承&quot;&gt;&lt;a href=&quot;#default-与多重继承&quot; class=&quot;headerlink&quot; title=&quot;default 与多重继承&quot;&gt;&lt;/a&gt;default 与多重继承&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>到底什么是系统编程？</title>
    <link href="http://yoursite.com/posts/2018/What-is-Systems-Programming-Really/"/>
    <id>http://yoursite.com/posts/2018/What-is-Systems-Programming-Really/</id>
    <published>2018-11-28T13:54:05.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>此文翻译自 Will Crichton 的博客中 2018 年 9 月 9 日的一篇文章。</p><p>原文：<a href="http://willcrichton.net/notes/systems-programming/" target="_blank" rel="noopener">What is Systems Programming, Really?</a></p><p>翻译者：<a href="http://nettee.github.io/" target="_blank" rel="noopener">nettee</a></p><p>译者前言：Go 语言诞生也将近十年了，但它的发展并没有很多人当时期望的那样如火如荼。按照 Go 是 “系统语言”的说法以及 Go 的语法设计，它似乎是以取代 C/C++ 为目标的。然而现如今 Go 没有撼动 C/C++ 一丝一毫的地位，倒是取代了一些 Python 在服务器端的工作。但 Go 语言的作者仍然坚称 Go 是“系统语言”。我们该如何看待“系统语言”这个术语？我们又该如何理解 Go 语言和最近流行的 Rust 语言的定位？我们究竟要不要学习它们？学习它们的什么地方？这篇文章梳理了程序语言的发展历史，能够给我们一个思路。</p><hr><p>前言：我对“系统编程” (systems programming) 这个词不太满意。对我而言，它实际上把两个概念混为一谈：“底层编程”（关注机器的实现细节），以及“系统设计”（创建并管理一系列复杂的交互的组件）。为什么会这样？这种情况持续了多久？重新定义“系统”这个概念，我们会得到什么启发？</p><h1 id="1970-年代：汇编之上的改进"><a href="#1970-年代：汇编之上的改进" class="headerlink" title="1970 年代：汇编之上的改进"></a>1970 年代：汇编之上的改进</h1><p>让我们回到现代计算机系统诞生的时候，看看这个术语是如何改变的。我不知道是谁最先创造了这个词语，但我发现对于“计算机系统”的定义始于 70 年代初期。在 <a href="https://www.sciencedirect.com/science/article/pii/S0065245808605100" target="_blank" rel="noopener">系统编程语言</a> (Bergeron et al. 1972) 中，作者写道：</p><blockquote><p>系统软件是一些子软件的集合。这些子软件形成一个整体，超过部分之和，并使整体有相当大的规模和复杂性。典型的例子包括 multiprogramming、翻译、模拟、信息管理、time sharing 的系统。[…] 下面是系统软件的几个特性。系统软件不必包含所有的特性，而且一些特性也会出现在非系统软件中。</p><ol><li>需要解决的问题内涵广泛，由许多（而且常常是多种多样）的子问题组成。 </li><li>系统程序可能是用于支持其他的软件和应用程序，也可能本身就是一个完整的应用程序。</li><li>它是为持续的“产业”使用而设计，而不是针对单个应用程序问题的一次性解决方案。</li><li>它可以持续地演化，支持不同数量和种类的特性。</li><li>系统程序无论是模块内还是模块间（即“通信”），都需要遵循一定的规则或结构。它常常是由多人设计并实现的。</li></ol></blockquote><p>这个定义还是比较合理的：计算机系统是大规模的、长期使用的、随时间变化的。然而，虽然定义中大部分是描述性的，有一个关键点却是限定性的：提倡区分底层语言和系统语言（在当时，也就是指区分汇编和 FORTRAN）。</p><blockquote><p>系统编程语言的目标是可以在不过分关注底层细节的情况下使用，但编译得到的底层代码不会比直接手写的差。这种语言需要结合高级语言的简洁性和可读性，以及汇编语言的时间空间效率、深入机器和操作系统的能力。它应该能在不带来额外系统资源开销的前提下，尽量减少设计、编写、调试的时间。</p></blockquote><p>与此同时，CMU 的研究人员发表了 <a href="https://www2.cs.arizona.edu/classes/cs520/spring06/bliss.pdf" target="_blank" rel="noopener">BLISS: 一个系统编程语言</a> (Wulf et al. 1972)，将其描述为：</p><a id="more"></a><blockquote><p>我们将 BLISS 称为“实现语言” (implementation language)。这个术语有些模糊不清，因为实际上所有的计算机语言都是为了实现些什么东西。对我们而言，这个词意味着一种通用的、高级的编程语言，它首要关注的是编写大型的生产软件系统之类的特定应用程序。特殊用途的语言（例如编译器的编译器）不在这一类，这些语言也不需要机器无关性。我们在定义中强调“实现”一词，而不是用“设计”或“文档”之类的词，是因为我们我们的语言不希望成为描述大型系统的最初设计的原型语言，也不希望成为系统的专有文档。一些诸如机器无关性、使用同一套记号表达设计和实现、自我文档等概念，显然都是可行的目标，也是我们评估各种语言的标准。</p></blockquote><p>作者定义“实现语言”为汇编之上、“设计语言”之下的一种语言。这和前一篇文章的定义一致，提倡在设计系统和实现系统时使用不同的语言。</p><p>这两篇文章都是研究中的产物，而我们要看的最后一篇文章（也是来自 1972 这个多产的年份！）是一篇学习系统编程的教学文章：<a href="https://dl.acm.org/citation.cfm?id=542917" target="_blank" rel="noopener">系统编程</a> (Donovan 1972)。</p><blockquote><p>什么是系统编程？你可以将计算机看成一种听从任何命令的野兽。有人说，人类用金属造出了计算机；也有人说，计算机用血和肉造出了人类。然而，当我们对计算机有点了解，就会发现它们是遵循非常具体和原始的指令的机器。在计算机的早期，人们使用代表原始指令的开关来与计算机通信。有些人想描述更复杂的指令。比如他们想表达：X = 30 * Y，当 Y = 10 时，X 是多少？如果没有系统语言的帮助，现代计算机无法理解这种语言。系统软件（编译器、loader、宏处理器、操作系统等）是让计算机能更好地适应用户的需要。然后，人们希望在编程的时候有更多机制的帮助。</p></blockquote><p><img src="/posts/2018/What-is-Systems-Programming-Really/systems-pyramid.png" alt="Systems pyramid"></p><p>我想这个定义提醒了我们，系统是为人服务的，即使是不直接面对终端用户的基础架构系统。</p><h1 id="1990-年代：脚本语言的兴起"><a href="#1990-年代：脚本语言的兴起" class="headerlink" title="1990 年代：脚本语言的兴起"></a>1990 年代：脚本语言的兴起</h1><p>在七八十年代，似乎研究人员都将系统语言看成和汇编语言对立的事物。这时候根本没有其他适合搭建系统的工具。（我不太确定 Lisp 是算什么？我读的材料中没有提到 Lisp 的，尽管我隐约记得 Lisp 机器曾短暂存在过。）</p><p>然而，在 90 年代中期，动态脚本语言的兴起给编程语言带来的巨大的改变。对早期 Bash 一类的 shell 脚本语言改进之后，Perl (1987), Tcl (1988), Python (1990), Ruby (1995), PHP (1995), 以及 Javascript (1995) 等一系列语言开始成为主流。这带来了一篇有影响力的文章“<a href="http://www.tcl.tk/doc/scripting.html" target="_blank" rel="noopener">脚本：21 世纪的高级编程语言</a>” (Ousterhout 1998)。这篇文章表达了“系统编程语言”与“脚本语言”的“Outsterhout 二分法”。</p><blockquote><p>脚本语言是针对与系统编程语言不同的任务而设计的，这导致了语言间的根本差异。系统语言是要从最原始的计算机元素（如内存中的字）开始，从头构造数据结构和算法。而脚本语言是为黏合而设计：假设已经存在一些功能强大的组件，脚本语言主要用于将组件连接在一起。系统语言是强类型的，以管理复杂性；而脚本语言的类型较弱，以简化组件间的连接，提供快速的应用程序开发。[…] 近年来，随着机器速度变快，脚本语言变得更好，图形用户界面、组件架构的重要性提高，以及互联网的发展，脚本语言的适用性变得越来越广。</p></blockquote><p><img src="/posts/2018/What-is-Systems-Programming-Really/ousterhouts-dichotomy.gif" alt="Ousterhouts dichotomy"></p><p>从技术层面看，Ousterhout 从“类型安全性”和“每个语句的信息量”两个纬度比较了脚本语言与系统语言。从设计层面而言，他为两类语言描述的新的角色：系统语言用于创建组件，而脚本语言用于黏合组件。</p><p>大约在这个时候，静态类型但支持垃圾回收的语言开始流行。Java (1995) 和 C# (2000) 成为我们今天所知的巨头。虽然这两个语言传统上不被认为是“系统语言”，但他们已经设计出了许多超大型的软件系统。Ousterhout 甚至明确提出：“在正在成形的互联网世界里，Java 就是系统编程的语言。”</p><h1 id="2010-年代：界线开始模糊"><a href="#2010-年代：界线开始模糊" class="headerlink" title="2010 年代：界线开始模糊"></a>2010 年代：界线开始模糊</h1><p>在过去十年中，脚本语言好系统编程语言之间的界线开始变得模糊。像 Dropbox 这样的公司能够只用 Python 就构建出巨大而且可扩展的系统。Javascript 也用来在数以万计的网页中渲染实时、复杂的界面。渐进类型系统 (gradual typing) 在 <a href="http://mypy-lang.org/" target="_blank" rel="noopener">Python</a>, <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">JavaScript</a> 等脚本语言中已经成为主流。开发者可以使用这种类型系统，在“原型”代码上逐步添加静态类型信息来过渡到“生产”代码。</p><p>与此同时，大量工程资源被用于开发 JIT 编译器，既包括静态语言的（如 Java 的 HotSpot），也包括动态语言的（如 Lua 的 LuaJIT，JavaScript 的 V8，Python 的 PyPy）。这些 JIT 编译器可以使语言的性能<a href="https://attractivechaos.github.io/plb/" target="_blank" rel="noopener">和传统的系统编程语言（C，C++）相媲美</a>。像 <a href="https://spark.apache.org/" target="_blank" rel="noopener">Spark</a> 这样大型可扩展的分布式系统也是用 Scala 写的。而像 Julia, Swift 和 Go 这样的新语言也在不断提升垃圾回收类语言的性能上限。</p><p>这里有一个叫做 <a href="https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond" target="_blank" rel="noopener">2014 年及以后的系统编程</a> 的座谈会，其中的几位嘉宾都是当今几个系统语言（自称）的创造者：C++ 的作者 Bjarne Stroustrup、Go 的作者 Rob Pike、D 开发者 Andrei Alexandrescu，以及 Rust 开发者 Niko Matsakis。当被问道“什么是如今的系统编程语言”时，他们回答到（整理稿）：</p><blockquote><ul><li><strong>Niko Matsakis</strong>: 写客户端应用程序用到的语言。这和 Go 面向的领域正好相反。客户端程序需要满足延迟、安全等标准，其中很多在服务器端是不会遇到的。</li><li><strong>Bjarne Stroustrup</strong>: 系统编程最开始是需要处理硬件的情况，不过后来应用程序变得更加复杂。你需要管理复杂性。如果你遇到了重大的资源限制，或者你需要细粒度的控制，那么你进入了系统编程的领域。编程中的限制决定了它是否是系统编程。内存够用吗？时间够用吗？</li><li><strong>Rob Pike</strong>: 我们发布 Go 的时候将其称为系统编程语言。这个词似乎不太恰当，因为很多人以为它是写操作系统的语言。我们觉得它更应该叫做“写服务器的语言”。现在 Go 成为了云平台语言，这样系统语言又可以定义为“跑在云上的语言”。</li><li><strong>Andrei Alexandrescu</strong>: 我有几个检验一个语言是不是系统语言的方法。系统语言必须能让你写出自己的内存分配器。系统语言应当能让你将一个整数转换为指针，因为硬件实际上就是这么工作的。</li></ul></blockquote><p>那么，系统语言意味着高性能？资源限制？硬件控制？云平台？概括说来，C, C++, Rust, D 这些语言因为对于机器的抽象层次而可以分为一类。这些语言暴露了底层硬件的细节，如内存分配/布局，以及细粒度的资源管理。</p><p>从另一个角度来看，当你遇到了效率问题，你有多大的自由度来解决它？底层编程语言的好处在于，当你发现了效率问题时，你可以通过仔细控制机器细节（如并行化指令，调整数据结构大小以保证其在缓存中，等等）来消除性能瓶颈。正如静态类型可以让你对“我要加的两个东西肯定都是整数” <em>更有信心</em> ，底层语言可以让你对“这段代码在机器上肯定会像我指定的一样执行” <em>更有信心</em> 。</p><p>相比之下，优化脚本语言就<a href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html" target="_blank" rel="noopener">相当难以捉摸</a>。你很难知道代码运行时是否和你期望的一致。自动并行化编译器遇到的是同样的问题——“自动并行化并不是一个编程模型”（参见 <a href="https://pharr.org/matt/blog/2018/04/18/ispc-origins.html" target="_blank" rel="noopener">ispc 的故事</a>）。就像在 Python 中写一个接口，你想的是 “我希望调用这个函数的人一定要传进一个整数”。</p><h1 id="今天：那么到底什么是系统编程呢？"><a href="#今天：那么到底什么是系统编程呢？" class="headerlink" title="今天：那么到底什么是系统编程呢？"></a>今天：那么到底什么是系统编程呢？</h1><p>这又让我想起了一开始那个问题。我认为很多人只是把系统编程看作是底层编程——一种暴露底层机器细节的方式。那么，系统又究竟如何定义呢？回顾 1972 年的那个定义：</p><blockquote><ol><li>需要解决的问题内涵广泛，由许多（而且常常是多种多样）的子问题组成。 </li><li>系统程序可能是用于支持其他的软件和应用程序，也可能本身就是一个完整的应用程序。</li><li>它是为持续的“产业”使用而设计，而不是针对单个应用程序问题的一次性解决方案。</li><li>它可以持续地演化，支持不同数量和种类的特性。</li><li>系统程序无论是模块内还是模块间（即“通信”），都需要遵循一定的规则或结构。它常常是由多人设计并实现的。</li></ol></blockquote><p>这几点看上去更像是软件工程的问题（模块化、重用、代码演化），而不是底层的性能问题。这意味着，任何注重于解决这些软件工程问题的编程语言，其实都可以叫做系统语言！当然，这不是说所有的语言都是系统语言——动态语言似乎仍然离系统语言很远，因为动态类型以及“请求宽恕，而不是许可”的格言（译注：Python等语言中一种“先进行处理，再解决异常”的编程风格）不利于良好的代码质量。</p><p>那么这个定义给我们带来了什么？有一个激进的观点： <strong> 像 OCaml 和 Haskell 这样的函数式语言，相比 C 或 C++ 这样的底层语言，其实更加面向系统 (system-oriented) </strong> 。当我们向本科生教授系统编程的时候，我们应该引入函数式编程的原则，例如不变性 (immutability) 的价值、丰富的类型系统对于提升接口设计的影响、以及高阶函数的作用。学校里应该既教授系统编程，又教授底层编程。</p><p>系统编程真的和好的软件工程是不同的吗？这不一定。但是问题在于，软件工程和底层编程通常是孤立地教授的。虽然大部分的软件工程课程是以 Java 为中心的 “书写良好的接口和测试”，但我们也应该教给学生如何设计有重大资源限制的系统。或许我们将底层编程叫做“系统编程”，是因为很多有趣的软件系统是底层的（如数据库、网络、操作系统等等）。由于底层系统有很多的限制，因此需要设计者进行创造性的思考。</p><p>另一个可以得出的结论是，底层程序员应该试图理解系统设计中的哪些想法可以应用于现代硬件上。我觉得 Rust 社区在这方面非常有创新性，寻找将好的软件设计/函数式编程的原则（如<a href="https://doc.rust-lang.org/book/2018-edition/ch04-00-understanding-ownership.html" target="_blank" rel="noopener">内存安全</a>、<a href="http://aturon.github.io/blog/2016/08/11/futures/" target="_blank" rel="noopener">future</a>、<a href="https://doc.rust-lang.org/book/2018-edition/ch09-00-error-handling.html" target="_blank" rel="noopener">错误处理</a>）应用到底层问题的方法。</p><p>总而言之，我们所谓的“系统编程”我认为应该叫做“底层编程”。“设计计算机系统”这个重要的领域，其实应该有自己独特的名字。通过将“系统编程”和“底层编程”两个概念区分开，我们就能在程序语言设计时的概念更加清晰。这也为系统和机器间共享见解提供了可能：我们如何为机器设计系统，我们又如何为系统设计机器？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文翻译自 Will Crichton 的博客中 2018 年 9 月 9 日的一篇文章。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://willcrichton.net/notes/systems-programming/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is Systems Programming, Really?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译者：&lt;a href=&quot;http://nettee.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者前言：Go 语言诞生也将近十年了，但它的发展并没有很多人当时期望的那样如火如荼。按照 Go 是 “系统语言”的说法以及 Go 的语法设计，它似乎是以取代 C/C++ 为目标的。然而现如今 Go 没有撼动 C/C++ 一丝一毫的地位，倒是取代了一些 Python 在服务器端的工作。但 Go 语言的作者仍然坚称 Go 是“系统语言”。我们该如何看待“系统语言”这个术语？我们又该如何理解 Go 语言和最近流行的 Rust 语言的定位？我们究竟要不要学习它们？学习它们的什么地方？这篇文章梳理了程序语言的发展历史，能够给我们一个思路。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前言：我对“系统编程” (systems programming) 这个词不太满意。对我而言，它实际上把两个概念混为一谈：“底层编程”（关注机器的实现细节），以及“系统设计”（创建并管理一系列复杂的交互的组件）。为什么会这样？这种情况持续了多久？重新定义“系统”这个概念，我们会得到什么启发？&lt;/p&gt;
&lt;h1 id=&quot;1970-年代：汇编之上的改进&quot;&gt;&lt;a href=&quot;#1970-年代：汇编之上的改进&quot; class=&quot;headerlink&quot; title=&quot;1970 年代：汇编之上的改进&quot;&gt;&lt;/a&gt;1970 年代：汇编之上的改进&lt;/h1&gt;&lt;p&gt;让我们回到现代计算机系统诞生的时候，看看这个术语是如何改变的。我不知道是谁最先创造了这个词语，但我发现对于“计算机系统”的定义始于 70 年代初期。在 &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0065245808605100&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统编程语言&lt;/a&gt; (Bergeron et al. 1972) 中，作者写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统软件是一些子软件的集合。这些子软件形成一个整体，超过部分之和，并使整体有相当大的规模和复杂性。典型的例子包括 multiprogramming、翻译、模拟、信息管理、time sharing 的系统。[…] 下面是系统软件的几个特性。系统软件不必包含所有的特性，而且一些特性也会出现在非系统软件中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要解决的问题内涵广泛，由许多（而且常常是多种多样）的子问题组成。 &lt;/li&gt;
&lt;li&gt;系统程序可能是用于支持其他的软件和应用程序，也可能本身就是一个完整的应用程序。&lt;/li&gt;
&lt;li&gt;它是为持续的“产业”使用而设计，而不是针对单个应用程序问题的一次性解决方案。&lt;/li&gt;
&lt;li&gt;它可以持续地演化，支持不同数量和种类的特性。&lt;/li&gt;
&lt;li&gt;系统程序无论是模块内还是模块间（即“通信”），都需要遵循一定的规则或结构。它常常是由多人设计并实现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个定义还是比较合理的：计算机系统是大规模的、长期使用的、随时间变化的。然而，虽然定义中大部分是描述性的，有一个关键点却是限定性的：提倡区分底层语言和系统语言（在当时，也就是指区分汇编和 FORTRAN）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统编程语言的目标是可以在不过分关注底层细节的情况下使用，但编译得到的底层代码不会比直接手写的差。这种语言需要结合高级语言的简洁性和可读性，以及汇编语言的时间空间效率、深入机器和操作系统的能力。它应该能在不带来额外系统资源开销的前提下，尽量减少设计、编写、调试的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与此同时，CMU 的研究人员发表了 &lt;a href=&quot;https://www2.cs.arizona.edu/classes/cs520/spring06/bliss.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BLISS: 一个系统编程语言&lt;/a&gt; (Wulf et al. 1972)，将其描述为：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Rust" scheme="http://yoursite.com/tags/Rust/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
  </entry>
  
  <entry>
    <title>C++ 函数可以直接返回一个对象吗？</title>
    <link href="http://yoursite.com/posts/2018/What-happens-when-return-an-object-by-value-in-Cpp/"/>
    <id>http://yoursite.com/posts/2018/What-happens-when-return-an-object-by-value-in-Cpp/</id>
    <published>2018-11-16T19:16:21.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>内存和资源管理是 C++ 最强的能力之一，也是 C++ 最复杂和最需要思考的地方。写 Java 的时候，我们只需要无脑地把所有对象都 <code>new</code> 出来。反正所有的对象只能放在堆区，又反正又垃圾回收器帮我们管理内存。然而，在 C++ 中，我们需要思考是把对象放在栈上，还是用 <code>new</code> 把对象放在堆上。默认情况下，对象会放在栈上，这样的好处是我们不会忘记释放对象的内存而造成内存泄漏。不过如果我们把一个大对象放在栈上，又将其作为参数或者返回值传递，就必须要考虑对象拷贝的开销了。C++ 由于和 C 兼容，默认情况下参数是按值传递 (call by value) 的，在传递参数和返回值的时候都会拷贝一遍对象。对于参数，我们尚可以将参数声明为引用类型 <code>T&amp;</code> 来避免对象拷贝。而对于返回值的拷贝开销，则是不能声明为引用类型来解决的。</p><h1 id="何时必须返回一个对象"><a href="#何时必须返回一个对象" class="headerlink" title="何时必须返回一个对象"></a>何时必须返回一个对象</h1><p>假设我们想写一个 <code>range</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; range(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> step=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i += step) &#123;</span><br><span class="line">        res.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会返回一个 <code>vector&lt;int&gt;</code> 对象，也就是我们不希望看到的：放在栈上的大对象。调用这个函数会产生返回值的临时对象，从而需要拷贝列表中的所有元素。很显然，你不能直接把返回值类型改成 <code>vector&lt;int&gt;&amp;</code> 来避免对象拷贝——编译器会产生一个警告：<code>warning: reference to local variable ‘res’ returned</code>，你返回了一个临时变量的引用，这个引用指向了一个栈上的地址，而这个地址随时可能被回收。这也是 C++ 初学者容易犯的一个错误。既然不能返回一个引用，又想避免对象拷贝的开销，很多“老” C++ 程序员会进行一个人肉优化：把返回值作为引用参数传进去。按这种方法，<code>range()</code> 函数可以改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; range(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> step=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i += step) &#123;</span><br><span class="line">        out.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">range(r, <span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>C/C++ 程序员可能非常习惯这样写。然而，必须承认这是一个丑陋的写法。那么，直接返回一个 <code>vector&lt;int&gt;</code> 对象到底会怎么样呢？对象拷贝的开销能否避免？</p><h1 id="临时对象与返回值优化"><a href="#临时对象与返回值优化" class="headerlink" title="临时对象与返回值优化"></a>临时对象与返回值优化</h1><p>根据 《深度探索 C++ 对象模型》第 2.3 节 “程序转化语意学” (Program Transformation Semantics) 所述，函数的返回值会做如下转化：</p><ol><li>添加一个临时变量 <code>__result</code></li><li>当函数返回时，调用 <code>__result</code> 的 copy constructor，使用返回值 <code>x</code> 作为参数</li><li>（如果有的话）对 <code>__result</code> 进行后续操作</li></ol><p>注意，后续操作中还能包括更多的 constructor，例如我们调用 <code>range</code> 函数以初始化变量 <code>r1</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r1;</span><br><span class="line">r1 = range(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 调用 r1 的 copy assignment operator (即 operator=)</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然只是简单的一次函数调用，临时对象就进行了两次拷贝。而 <code>range</code> 产生的数越多，需要拷贝的内容就越多，对性能的影响就越大。</p><p>为了解决这个问题，很多 C++ 编译器都实现了 <a href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization" target="_blank" rel="noopener">返回值优化</a> (Return Value Optimization)，来消除返回值临时对象的多次拷贝。</p><a id="more"></a><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>为了验证编译器进行返回值优化前后的不同，我们运行一个完整的例子。我们定义 <code>Blob</code> 类用于保存原始的二进制数据块。<code>Blob</code> 需要自己分配空间以存储数据，因此它需要实现 destructor, copy constructor 和 copy assignment operator。所有的 constructor 和 destructor 都会调用 logging 函数，让我们能看出它们的调用顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Blob()</span><br><span class="line">    : data_(<span class="literal">nullptr</span>), size_(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"Blob's default constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Blob</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    : data_(new char[size]), size_(size) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"Blob's parameter constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Blob() &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"Blob's destructor"</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Blob(<span class="keyword">const</span> Blob&amp; other) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"Blob's copy constructor"</span>);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[other.size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, other.data_, other.size_);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Blob&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Blob&amp; other) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"Blob's copy assignment operator"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[other.size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, other.data_, other.size_);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">void</span>* src)</span> </span>&#123;</span><br><span class="line">        len = min(len, size_ - offset);</span><br><span class="line">        <span class="built_in">memcpy</span>(data_ + offset, src, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* data_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们定义 <code>createBlob</code> 函数，由字符串创建 blob，并调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Blob <span class="title">createBlob</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="function">Blob <span class="title">blob</span><span class="params">(len)</span></span>;</span><br><span class="line">    blob.<span class="built_in">set</span>(<span class="number">0</span>, len, str);</span><br><span class="line">    <span class="keyword">return</span> blob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Blob blob;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Start assigning value..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    blob = createBlob(<span class="string">"A very very very long string representing serialized data"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"End assigning value"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createBlob</code> 函数返回了一个 <code>Blob</code> 对象，产生一个临时对象，这个临时对象会赋值给 <code>blob</code> 变量。那么我们应该能观察到很多的 constructor 和 destructor 调用。不过，现在编译器一般会默认进行返回值优化，消除掉很多不必要的 constructor 调用。为了观察最坏情况下的 constructor 调用情况，我们使用 <code>-fno-elide-constructors</code> 编译选项让编译器不进行返回值优化。</p><p>不进行返回值优化的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0x7ffd220ada20] Blob&apos;s default constructor</span><br><span class="line">Start assigning value...</span><br><span class="line">[0x7ffd220ad9e0] Blob&apos;s parameter constructor</span><br><span class="line">[0x7ffd220ada30] Blob&apos;s copy constructor</span><br><span class="line">[0x7ffd220ad9e0] Blob&apos;s destructor</span><br><span class="line">[0x7ffd220ada20] Blob&apos;s copy assignment operator</span><br><span class="line">[0x7ffd220ada30] Blob&apos;s destructor</span><br><span class="line">End assigning value</span><br><span class="line">[0x7ffd220ada20] Blob&apos;s destructor</span><br></pre></td></tr></table></figure><p>可以看到，编译器生成了一个地址为 0x7ffd220ada30 的临时对象，临时对象需要调用一次 copy constructor 和 destructor。其中，copy constructor 需要复制 blob 中的数据，开销巨大。</p><p>进行返回值优化的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0x7ffdd52c7d50] Blob&apos;s default constructor</span><br><span class="line">Start assigning value...</span><br><span class="line">[0x7ffdd52c7d60] Blob&apos;s parameter constructor</span><br><span class="line">[0x7ffdd52c7d50] Blob&apos;s copy assignment operator</span><br><span class="line">[0x7ffdd52c7d60] Blob&apos;s destructor</span><br><span class="line">End assigning value</span><br><span class="line">[0x7ffdd52c7d50] Blob&apos;s destructor</span><br></pre></td></tr></table></figure><p>编译器帮助我们优化掉了这个不需要的临时对象。然而，在实际的比较复杂的情况下（例如函数里 <code>if</code> 语句的两个分支分别返回不同的对象），编译器可能无法进行返回值优化。那么，我们需要更好的方法来消除临时对象的不利影响。C++11 中引入的 <em>移动语义</em> (move semantics) 可以很好地解决这个问题。</p><h1 id="移动语义与-move-constructor"><a href="#移动语义与-move-constructor" class="headerlink" title="移动语义与 move constructor"></a>移动语义与 move constructor</h1><p>移动语义是 C++11 标准中引入的重要概念。移动语义类似 Rust 中的“所有权转移”。Move constructor 接收的是“右值引用”。在一般情况下，由于右值只是一个临时变量，我们可以“偷走”右值对象中的内容，而不会引起其他影响。在 C++11 中，移动语义才是真正重要的。Move constructor 如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Blob(Blob&amp;&amp; other) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"Blob's move constructor"</span>);</span><br><span class="line">    swap(data_, other.data_);</span><br><span class="line">    swap(size_, other.size_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Blob&amp; <span class="keyword">operator</span>=(Blob&amp;&amp; other) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"Blob's move assignment operator"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(data_, other.data_);</span><br><span class="line">    swap(size_, other.size_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再进行代码，观察 constructor 的调用情况。</p><p>不进行返回值优化的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0x7ffef7172f70] Blob&apos;s default constructor</span><br><span class="line">Start assigning value...</span><br><span class="line">[0x7ffef7172f30] Blob&apos;s parameter constructor</span><br><span class="line">[0x7ffef7172f80] Blob&apos;s move constructor</span><br><span class="line">[0x7ffef7172f30] Blob&apos;s destructor</span><br><span class="line">[0x7ffef7172f70] Blob&apos;s move assignment operator</span><br><span class="line">[0x7ffef7172f80] Blob&apos;s destructor</span><br><span class="line">End assigning value</span><br><span class="line">[0x7ffef7172f70] Blob&apos;s destructor</span><br></pre></td></tr></table></figure><p>进行返回值优化的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0x7ffc18a6e2a0] Blob&apos;s default constructor</span><br><span class="line">Start assigning value...</span><br><span class="line">[0x7ffc18a6e2b0] Blob&apos;s parameter constructor</span><br><span class="line">[0x7ffc18a6e2a0] Blob&apos;s move assignment operator</span><br><span class="line">[0x7ffc18a6e2b0] Blob&apos;s destructor</span><br><span class="line">End assigning value</span><br><span class="line">[0x7ffc18a6e2a0] Blob&apos;s destructor</span><br></pre></td></tr></table></figure><p>可以发现，这次的运行结果相当于将前一次运行中的所有 copy constructor / copy assignment operator 换成了 move constructor / move assignment operator。可以看到，移动语义带来的性能优化实际上和 RVO 是正交的：RVO 负责消除多余的临时变量和 constructor；移动语义则负责将开销较大的 copy constructor 换成 move constructor。</p><p>最后，现代的很多编译器已经可以自动添加 move constructor 了，编译器的 RVO 也做得越来越好。老的 C++ 程序员的写法似乎更像是一种“人肉编译器”的写法。我们必须要知道的一点是：编译器肯定是会越做越好的，而且编译器的能力常常远超过我们的想象。所以，我们更好的办法是将代码写得更优雅已读，如返回值拷贝开销这样的问题，更应该交给编译器去完成。</p><!-- TODO: https://www.zhihu.com/question/29511959-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存和资源管理是 C++ 最强的能力之一，也是 C++ 最复杂和最需要思考的地方。写 Java 的时候，我们只需要无脑地把所有对象都 &lt;code&gt;new&lt;/code&gt; 出来。反正所有的对象只能放在堆区，又反正又垃圾回收器帮我们管理内存。然而，在 C++ 中，我们需要思考是把对象放在栈上，还是用 &lt;code&gt;new&lt;/code&gt; 把对象放在堆上。默认情况下，对象会放在栈上，这样的好处是我们不会忘记释放对象的内存而造成内存泄漏。不过如果我们把一个大对象放在栈上，又将其作为参数或者返回值传递，就必须要考虑对象拷贝的开销了。C++ 由于和 C 兼容，默认情况下参数是按值传递 (call by value) 的，在传递参数和返回值的时候都会拷贝一遍对象。对于参数，我们尚可以将参数声明为引用类型 &lt;code&gt;T&amp;amp;&lt;/code&gt; 来避免对象拷贝。而对于返回值的拷贝开销，则是不能声明为引用类型来解决的。&lt;/p&gt;
&lt;h1 id=&quot;何时必须返回一个对象&quot;&gt;&lt;a href=&quot;#何时必须返回一个对象&quot; class=&quot;headerlink&quot; title=&quot;何时必须返回一个对象&quot;&gt;&lt;/a&gt;何时必须返回一个对象&lt;/h1&gt;&lt;p&gt;假设我们想写一个 &lt;code&gt;range&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; range(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; begin, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = begin; i &amp;lt; end; i += step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res.push_back(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码会返回一个 &lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt; 对象，也就是我们不希望看到的：放在栈上的大对象。调用这个函数会产生返回值的临时对象，从而需要拷贝列表中的所有元素。很显然，你不能直接把返回值类型改成 &lt;code&gt;vector&amp;lt;int&amp;gt;&amp;amp;&lt;/code&gt; 来避免对象拷贝——编译器会产生一个警告：&lt;code&gt;warning: reference to local variable ‘res’ returned&lt;/code&gt;，你返回了一个临时变量的引用，这个引用指向了一个栈上的地址，而这个地址随时可能被回收。这也是 C++ 初学者容易犯的一个错误。既然不能返回一个引用，又想避免对象拷贝的开销，很多“老” C++ 程序员会进行一个人肉优化：把返回值作为引用参数传进去。按这种方法，&lt;code&gt;range()&lt;/code&gt; 函数可以改写如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; range(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; out, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; begin, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = begin; i &amp;lt; end; i += step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        out.push_back(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Caller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;range(r, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C/C++ 程序员可能非常习惯这样写。然而，必须承认这是一个丑陋的写法。那么，直接返回一个 &lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt; 对象到底会怎么样呢？对象拷贝的开销能否避免？&lt;/p&gt;
&lt;h1 id=&quot;临时对象与返回值优化&quot;&gt;&lt;a href=&quot;#临时对象与返回值优化&quot; class=&quot;headerlink&quot; title=&quot;临时对象与返回值优化&quot;&gt;&lt;/a&gt;临时对象与返回值优化&lt;/h1&gt;&lt;p&gt;根据 《深度探索 C++ 对象模型》第 2.3 节 “程序转化语意学” (Program Transformation Semantics) 所述，函数的返回值会做如下转化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加一个临时变量 &lt;code&gt;__result&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当函数返回时，调用 &lt;code&gt;__result&lt;/code&gt; 的 copy constructor，使用返回值 &lt;code&gt;x&lt;/code&gt; 作为参数&lt;/li&gt;
&lt;li&gt;（如果有的话）对 &lt;code&gt;__result&lt;/code&gt; 进行后续操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，后续操作中还能包括更多的 constructor，例如我们调用 &lt;code&gt;range&lt;/code&gt; 函数以初始化变量 &lt;code&gt;r1&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; r1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r1 = range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 调用 r1 的 copy assignment operator (即 operator=)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，虽然只是简单的一次函数调用，临时对象就进行了两次拷贝。而 &lt;code&gt;range&lt;/code&gt; 产生的数越多，需要拷贝的内容就越多，对性能的影响就越大。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，很多 C++ 编译器都实现了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;返回值优化&lt;/a&gt; (Return Value Optimization)，来消除返回值临时对象的多次拷贝。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>理解 C/C++ 中的左值和右值</title>
    <link href="http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/"/>
    <id>http://yoursite.com/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</id>
    <published>2018-10-16T19:58:54.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 Eli Bendersky’s website。</p><p>原文：<a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">Understanding lvalues and rvalues in C and C++</a></p><p>翻译者：<a href="http://nettee.github.io" target="_blank" rel="noopener">nettee</a></p><hr><p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值 (rvalue)</em> 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 <code>gcc</code> 编译以下代码时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo() = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.c: In function &apos;main&apos;:</span><br><span class="line">test.c:8:5: error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure><p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值 (lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在错误信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testcpp.cpp: In function &apos;int&amp; foo()&apos;:</span><br><span class="line">testcpp.cpp:5:12: error: invalid initialization of non-const reference of type &apos;int&amp;&apos; from an rvalue of type &apos;int&apos;</span><br></pre></td></tr></table></figure><p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，<em>左值</em> 和 <em>右值</em> 到底是什么意思呢？我这篇文章将会详细解释。</p><a id="more"></a><h1 id="简单的定义"><a href="#简单的定义" class="headerlink" title="简单的定义"></a>简单的定义</h1><p>这里我故意给出了一个 <em>左值</em> 和 <em>右值</em> 的简化版定义。文章剩下的部分还会进行详细解释。</p><p><em>左值 (lvalue, locator value)</em> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><em>右值 (rvalue)</em> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var;</span><br><span class="line">var = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code> 是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 = var;       // 错误！</span><br><span class="line">(var + 1) = 4; // 错误！</span><br></pre></td></tr></table></figure><p>常量 <code>4</code> 和表达式 <code>var + 1</code> 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p><p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code> 返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到 <code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p><p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++ 的引用让我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int globalvar = 20;</span><br><span class="line"></span><br><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return globalvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 10;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>foo</code> 返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++ 中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符 <code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code> 中的方括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;int, float&gt; mymap;</span><br><span class="line">mymap[10] = 5.6;</span><br></pre></td></tr></table></figure><p>之所以能赋值给 <code>mymap[10]</code>，是因为 <code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p><h1 id="可修改的左值"><a href="#可修改的左值" class="headerlink" title="可修改的左值"></a>可修改的左值</h1><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C 加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 'a' 是左值</span></span><br><span class="line">a = <span class="number">10</span>;           <span class="comment">// 但不可以赋值给它！</span></span><br></pre></td></tr></table></figure><p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为 <em>可修改左值 (modifiable lvalues)</em> 。C99标准定义可修改左值为：</p><blockquote><p>[…] 可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 <code>struct</code> 或 <code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p></blockquote><h1 id="左值与右值间的转换"><a href="#左值与右值间的转换" class="headerlink" title="左值与右值间的转换"></a>左值与右值间的转换</h1><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符 <code>&#39;+&#39;</code> 就需要两个右值参数，并返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// + 需要右值，所以 a 和 b 被转换成右值</span></span><br><span class="line">               <span class="comment">// + 返回右值</span></span><br></pre></td></tr></table></figure><p>在例子中，<code>a</code> 和 <code>b</code> 都是左值。因此，在第三行中，它们经历了隐式的 <em>左值到右值转换</em> 。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p><p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p><p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符 <code>&#39;*&#39;</code> 需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span></span><br></pre></td></tr></table></figure><p>相反地，一元取地址操作符 <code>&#39;&amp;&#39;</code> 需要一个左值参数，返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// 错误: 一元 '&amp;' 操作符需要左值参数</span></span><br><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// 正确: var 是左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// 错误: 赋值操作的左操作数需要是左值</span></span><br></pre></td></tr></table></figure><p>在 C++ 中 <code>&#39;&amp;&#39;</code> 符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; sref = std::string();  // 错误: 非常量的引用 &apos;std::string&amp;&apos; 错误地使用右值 &apos;std::string` 初始化</span><br></pre></td></tr></table></figure><p><em>常量的</em> 左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得 C++ 中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><h1 id="CV-限定的右值"><a href="#CV-限定的右值" class="headerlink" title="CV 限定的右值"></a>CV 限定的右值</h1><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的 C++11 标准草稿的第 4.1 节】，我们会发现：</p><blockquote><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T 不是类类型【译注：类类型即 C++ 中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定 CV 的版本 (cv-unqualified version of T)。其他情况下，转换后的右值类型就是 T 本身。</p></blockquote><p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <em>CV 限定符</em> 这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++ 标准的 3.9.3 节写到：</p><blockquote><p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、 <em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV 限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p></blockquote><p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV 限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV 限定的类型，但内置类型 (如 <code>int</code>) 则没有。考虑下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bar().foo();  <span class="comment">// calls foo</span></span><br><span class="line">    cbar().foo(); <span class="comment">// calls foo const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code> 中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是 <code>const A</code>，这和 <code>A</code> 是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code> 的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><h1 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++11 的右值引用"></a>C++11 的右值引用</h1><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义 (move semantics)</em> 概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references” 可以找到很多相关的资料，几个个人认为有用的资料：<a href="http://www.artima.com/cppsource/rvalue.html" target="_blank" rel="noopener">这一篇</a>， <a href="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x" target="_blank" rel="noopener">这一篇</a>，特别是 <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p><p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11 改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>假设我们要实现一个“整数的 vector”，一些相关的函数可能是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intvec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="keyword">size_t</span> num = <span class="number">0</span>)</span></span></span><br><span class="line">        : m_size(num), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Intvec()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"destructor"</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">            m_data = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intvec(<span class="keyword">const</span> Intvec&amp; other)</span><br><span class="line">        : m_size(other.m_size), m_data(<span class="keyword">new</span> <span class="keyword">int</span>[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"copy constructor"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span><br><span class="line">            m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Intvec&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span><br><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span><br><span class="line">        <span class="built_in">std</span>::swap(m_data, tmp.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"] "</span> &lt;&lt; msg &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line">    <span class="keyword">int</span>* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor) 和拷贝赋值操作符 (copy assignment operator) 【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个 logging 函数，让我们能知道是否调用了它们。</p><p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">Intvec v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning lvalue...\n"</span>;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning lvalue...\n"</span>;</span><br></pre></td></tr></table></figure><p>运行输出的结果是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning lvalue...</span><br><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span><br><span class="line">[<span class="number">0x28fec8</span>] destructor</span><br><span class="line">ended assigning lvalue...</span><br></pre></td></tr></table></figure><p>这是正常的结果，准确展示了 <code>operator=</code> 的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"assigning rvalue...\n"</span>;</span><br><span class="line">v2 = Intvec(<span class="number">33</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ended assigning rvalue...\n"</span>;</span><br></pre></td></tr></table></figure><p>虽然这里的例子中是赋值一个新创建的 vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给 <code>v2</code> （例如当一个函数返回 vector 的情况）。我们会得到这样的输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[<span class="number">0x28ff08</span>] constructor</span><br><span class="line">[<span class="number">0x28fef8</span>] copy assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28fec8</span>] copy constructor</span><br><span class="line">[<span class="number">0x28fec8</span>] destructor</span><br><span class="line">[<span class="number">0x28ff08</span>] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure><p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了 <em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p><p>不过现在你不需要多一个临时对象了。C++11 引入了右值引用，让我们可以实现“移动语义” (move semantics)，特别是可以实现“移动赋值操作符” (move assignment operator) 【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copy assignment operator)。在 C++11 中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code> 加上另一个 <code>operator=</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号 <code>&amp;&amp;</code> 代表了新的 <em>右值引用 (rvalue reference)</em> 。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[<span class="number">0x28ff08</span>] constructor</span><br><span class="line">[<span class="number">0x28fef8</span>] move assignment <span class="keyword">operator</span></span><br><span class="line">[<span class="number">0x28ff08</span>] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure><p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然 <code>Intvec(33)</code> 仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p><p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个 C++ 中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>即使不考虑左值和右值的问题，你也可以写很多 C++ 代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些 C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p><p>另外，在新的 C++ 规范中，因为 C++11 引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 Eli Bendersky’s website。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding lvalues and rvalues in C and C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译者：&lt;a href=&quot;http://nettee.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们在 C/C++ 编程中并不会经常用到 &lt;em&gt;左值 (lvalue)&lt;/em&gt; 和 &lt;em&gt;右值 (rvalue)&lt;/em&gt; 两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用 &lt;code&gt;gcc&lt;/code&gt; 编译以下代码时：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo() = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你会得到：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.c: In function &amp;apos;main&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test.c:8:5: error: lvalue required as left operand of assignment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值 (lvalue)。另一个例子是当你用 &lt;code&gt;g++&lt;/code&gt; 编译以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在错误信息是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;testcpp.cpp: In function &amp;apos;int&amp;amp; foo()&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testcpp.cpp:5:12: error: invalid initialization of non-const reference of type &amp;apos;int&amp;amp;&amp;apos; from an rvalue of type &amp;apos;int&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，&lt;em&gt;左值&lt;/em&gt; 和 &lt;em&gt;右值&lt;/em&gt; 到底是什么意思呢？我这篇文章将会详细解释。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java 命令行交互输入库 JLine 入门</title>
    <link href="http://yoursite.com/posts/2018/Getting-Started-with-JLine/"/>
    <id>http://yoursite.com/posts/2018/Getting-Started-with-JLine/</id>
    <published>2018-09-03T15:04:00.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，软件的用户界面无非分为 GUI （图形用户界面）和 CLI （命令行用户界面）。对于我们经常使用 Linux 的人来说，命令行界面一定非常熟悉。无论是 Shell 里输入命令的界面，还是如 GDB 等软件的内部交互界面，都是命令行界面。而当我们开发自己的软件，要写认真写一个 CLI 的时候，却发现要手写做出一个好用的命令行界面其实非常困难。因为一个好的命令行界面，在输入/输出之外，还要支持一些常见的命令行功能。</p><p>对我而言，一个合格的命令行软件界面应该支持这三个功能：</p><ul><li>自动补全：当按下 TAB 键时，在当前光标处进行内容补全。根据上下文信息，补全可能是对命令的补全，也可能是对文件路径的补全。</li><li>命令历史：当按上/下方向键时，可以显示上一条/下一条命令。</li><li>行编辑 (line editing)：可以使用 Emacs 快捷键进行行内的编辑功能，例如 Ctrl+A 移动光标至行首，Ctrl+E 移动光标至行尾。</li></ul><p>熟悉 Linux 的人会发现，上面这三个功能都是 <a href="https://en.wikipedia.org/wiki/GNU_Readline" target="_blank" rel="noopener">GNU Readline</a> 的功能。我们不需要在软件中手写这几个功能，只要用这样一个库就可以了。实际上，GNU/Linux 中使用 GNU Readline 库的软件非常多，这使得 GNU Readline 同时也成为了一个事实上的命令行交互标准。GNU Readline 是 C 语言的库。我们用其他语言的时候，就要找对应功能的库（这往往是封装了底层的 GNU Readline 的库）。对 Java 语言来说，<a href="https://github.com/jline/jline3" target="_blank" rel="noopener">JLine</a> 就是这样一个帮助你搭建一个命令行交互界面的库。</p><p>本文是想通过一个例子介绍 JLine3 的基本用法。JLine3 并没有一个 “Hello, world!” 的例子，它的 <a href="https://github.com/jline/jline3/wiki" target="_blank" rel="noopener">wiki</a> 也写得非常简略。虽然有一个示例的程序 <a href="https://github.com/jline/jline3/blob/master/builtins/src/test/java/org/jline/example/Example.java" target="_blank" rel="noopener">Example.java</a>，但这个示例比较复杂，难以理解。希望本文的内容能对你理解 JLine3 的用法有所帮助。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>我们尝试为软件 Fog 设计一个命令行用户界面。用户可以输入四种命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE [FILE_NAME]</span><br><span class="line">OPEN [FILE_NAME] AS [FILE_VAR]</span><br><span class="line">WRITE TIME|DATE|LOCATION TO [FILE_VAR]</span><br><span class="line">CLOSE [FILE_VAR]</span><br></pre></td></tr></table></figure><a id="more"></a><p>下面我们将一步步地写出 Fog 软件的命令行界面。首先，用 JLine3 搭建一个最基础的 REPL (Read-Eval-Print Loop) 框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Terminal terminal = TerminalBuilder.builder()</span><br><span class="line">        .system(<span class="keyword">true</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">"fog&gt; "</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        line = lineReader.readLine(prompt);</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UserInterruptException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (EndOfFileException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"\nBye."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除了设置命令提示符 (prompt)，没有进行任何特殊的设置。命令行会将用户输入的一行原样打印出来。当用户输入 Ctrl+D (End of line) 时，程序会退出。</p><p>即使我们只写了一个框架，但此时程序已经拥有了 JLine3 默认提供的命令历史和行编辑功能。此时按上/下方向键时，会显示上一条/下一条命令，也可以使用 Ctrl+A、Ctrl+E 等 Emacs 快捷键进行行内编辑。</p><h2 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h2><h3 id="简单补全与复合补全"><a href="#简单补全与复合补全" class="headerlink" title="简单补全与复合补全"></a>简单补全与复合补全</h3><p>由于命令补全和程序的命令格式密切相关，所以我们必须自己定义补全的方式。根据 <a href="https://github.com/jline/jline3/wiki" target="_blank" rel="noopener">wiki</a> 中所写，JLine3 中定义命令补全的方式是：创建一个 <code>Completer</code> 类的实例，将其传入 <code>LineReader</code>。JLine3 内置了多个 completer，其中最常见的是 <code>FileNameCompleter</code> （补全文件名）和 <code>StringsCompleter</code> （根据预定义的几个字符串进行补全，用于命令名或参数名）。例如，Fog 程序的四个命令分别以 CREATE, OPEN, WRITE, CLOSE 开头，那么我们可以使用一个 <code>StringsCompleter</code> 来对命令的第一个单词进行补全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Completer commandCompleter = <span class="keyword">new</span> StringsCompleter(<span class="string">"CREATE"</span>, <span class="string">"OPEN"</span>, <span class="string">"WRITE"</span>, <span class="string">"CLOSE"</span>);</span><br><span class="line"></span><br><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .completer(commandCompleter)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>然而，这种补全方式只能支持每个命令的第一个单词，我们想要在命令的各种可能的地方都进行补全该怎么办呢？这时候就需要将 completer 进行组合，形成 <strong>复合 completer</strong> 。一般情况下，<code>StringsCompleter</code> 这样的 <strong>简单 completer</strong> 只能负责一个单词的补全，而要想实现整条命令的补全，就需要将几个不同的 completer 组合起来使用。<code>ArgumentCompleter</code> 就是用来补全整条命令的复合 completer。它可以将若干个 completer 组合在一起，每个 completer 负责补全命令中的第 i 个单词。以 CREATE 命令为例，这条命令共有两个单词，第一个单词需要字符串补全，第二个单词需要文件名补全。于是我们使用 <code>ArgumentCompleter</code> 将 <code>StringsCompleter</code> 和 <code>FileNameCompleter</code> 组合起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Completer createCompleter = <span class="keyword">new</span> ArgumentCompleter(</span><br><span class="line">        <span class="keyword">new</span> StringsCompleter(<span class="string">"CREATE"</span>),</span><br><span class="line">        <span class="keyword">new</span> Completers.FileNameCompleter()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .completer(createCompleter)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>根据 <code>ArgumentCompleter</code> 的两个参数，在输入第一个单词的时候会补全 CREATE，输入第二个单词的时候会补全文件名。但实测时会发现一个问题：当你已经输入了 CREATE 和文件名后，再试图进行补全，在第三个单词处试图补全，还是会出现文件名的补全。这是因为，<code>ArgumentCompleter</code> 在你已经“用完了”所有的 completers 之后（即第三个单词开始），会默认使用最后一个 completer。这并不是我们想要的效果。为了解决这个问题，我们可以在最后添加一个 <code>NullCompleter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Completer createCompleter = <span class="keyword">new</span> ArgumentCompleter(</span><br><span class="line">        <span class="keyword">new</span> StringsCompleter(<span class="string">"CREATE"</span>),</span><br><span class="line">        <span class="keyword">new</span> Completers.FileNameCompleter(),</span><br><span class="line">        NullCompleter.INSTANCE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .completer(createCompleter)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p><code>NullCompleter</code> 即不进行任何补全。这样，从第三个单词开始，都不会进行任何多余的补全。</p><p>类似地，我们再加入 OPEN 命令补全的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Completer createCompleter = <span class="keyword">new</span> ArgumentCompleter(</span><br><span class="line">        <span class="keyword">new</span> StringsCompleter(<span class="string">"CREATE"</span>),</span><br><span class="line">        <span class="keyword">new</span> Completers.FileNameCompleter(),</span><br><span class="line">        NullCompleter.INSTANCE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Completer openCompleter = <span class="keyword">new</span> ArgumentCompleter(</span><br><span class="line">        <span class="keyword">new</span> StringsCompleter(<span class="string">"OPEN"</span>),</span><br><span class="line">        <span class="keyword">new</span> Completers.FileNameCompleter(),</span><br><span class="line">        <span class="keyword">new</span> StringsCompleter(<span class="string">"AS"</span>),</span><br><span class="line">        NullCompleter.INSTANCE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Completer fogCompleter = <span class="keyword">new</span> AggregateCompleter(</span><br><span class="line">        createCompleter,</span><br><span class="line">        openCompleter</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .completer(fogCompleter)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>这里有两点需要注意的地方：</p><ol><li>CREATE 命令和 OPEN 命令分别定义了 completer，再用 <code>AggregateCompleter</code> 组合起来。<code>AggregateCompleter</code> 是另一种复合 completer，将多种可能的补全方式组合到了一起。打比方来说，<code>ArgumentCompleter</code> 相当于串联电路，而 <code>AggregateCompleter</code> 相当于并联电路。</li><li>OPEN 命令的 <code>ArgumentCompleter</code> 中只定义了前三个单词的补全方式。这是因为第四个单词是用户定义了文件变量，用户可能输入任何的名字，因此无法进行补全。</li></ol><h3 id="动态补全"><a href="#动态补全" class="headerlink" title="动态补全"></a>动态补全</h3><p>WRITE 命令的补全与前两个稍有不同。根据程序语义，只有用户在 OPEN 命令中定义了的文件变量才能在 WRITE 命令中使用。那么，在补全的时候也应该考虑这一点。我们需要在运行时动态地调整补全候选词：每当用户使用 OPEN 命令打开一个文件后，都调整 completer，将新的文件变量纳入补全候选词。我们需要知道如何动态地修改 completer。虽然 completer 的创建和传递给 <code>LineReader</code> 的过程是静态的，但在程序运行时，是通过调用 <code>Completer.complete()</code> 来获取补全的候选词的。那么，我们可以继承 <code>Completer</code> 并重写 <code>complete()</code> 方法来实现动态的候选词调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileVarsCompleter</span> <span class="keyword">implements</span> <span class="title">Completer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Completer completer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileVarsCompleter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = <span class="keyword">new</span> StringsCompleter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(LineReader reader, ParsedLine line, List&lt;Candidate&gt; candidates)</span> </span>&#123;</span><br><span class="line">        completer.complete(reader, line, candidates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileVars</span><span class="params">(List&lt;String&gt; fileVars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = <span class="keyword">new</span> StringsCompleter(fileVars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>setFileVars()</code> 时，会重新创建一个新的 <code>StringsCompleter</code>，从而扩充候选词。而在 REPL 中，只需要在用户输入 OPEN 命令后，调用 <code>setFileVars()</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; fileVars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileVarsCompleter fileVarsCompleter = <span class="keyword">new</span> FileVarsCompleter();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        Completer writeCompleter = <span class="keyword">new</span> ArgumentCompleter(</span><br><span class="line">                <span class="keyword">new</span> StringsCompleter(<span class="string">"WRITE"</span>),</span><br><span class="line">                <span class="keyword">new</span> StringsCompleter(<span class="string">"TIME"</span>, <span class="string">"DATE"</span>, <span class="string">"LOCATION"</span>),</span><br><span class="line">                <span class="keyword">new</span> StringsCompleter(<span class="string">"TO"</span>),</span><br><span class="line">                fileVarsCompleter,</span><br><span class="line">                NullCompleter.INSTANCE</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Completer fogCompleter = <span class="keyword">new</span> AggregateCompleter(</span><br><span class="line">                createCompleter,</span><br><span class="line">                openCompleter,</span><br><span class="line">                writeCompleter</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        String prompt = <span class="string">"fog&gt; "</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                line = lineReader.readLine(prompt);</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                <span class="keyword">if</span> (line.startsWith(<span class="string">"OPEN"</span>)) &#123;</span><br><span class="line">                    fileVars.add(line.split(<span class="string">" "</span>)[<span class="number">3</span>]);</span><br><span class="line">                    fileVarsCompleter.setFileVars(fileVars);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UserInterruptException e) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (EndOfFileException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"\nBye."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>前面已经过说，在默认情况下，JLine3 已经支持命令历史查找。不过我们想加上一个特殊的功能：用户输入的注释（以 # 开头）不会进入命令历史，从而在命令历史查找时不受注释内容的干扰。</p><p>JLine3 中，<code>History</code> 负责控制历史记录的行为，其默认实现为 <code>DefaultHistory</code>。查看源代码，我们发现 <code>add()</code> 方法是其核心行为。用户输入的一行命令，会通过 <code>add()</code> 方法加入命令历史中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Instant time, String line)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(time);</span><br><span class="line">    Objects.requireNonNull(line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getBoolean(reader, LineReader.DISABLE_HISTORY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    internalAdd(time, line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们可以通过继承并重写 <code>add()</code> 方法，将注释内容过滤掉，不加入命令历史：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FogHistory</span> <span class="keyword">extends</span> <span class="title">DefaultHistory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isComment</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> line.startsWith(<span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Instant time, String line)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isComment(line)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.add(time, line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们这样设置 <code>LineReader</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LineReader lineReader = LineReaderBuilder.builder()</span><br><span class="line">        .terminal(terminal)</span><br><span class="line">        .completer(fogCompleter)</span><br><span class="line">        .history(<span class="keyword">new</span> FogHistory())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现，JLine3 的各个功能设计得比较清晰，有其对应的接口和默认实现。如果我们想自定义一些特性，一般通过继承并重写的方式可以做到。JLine3 的源代码也比较容易理解，遇到困难时，可以自己阅读源代码来寻找线索。</p><p>本文中示例程序的完整代码参见 <a href="https://github.com/nettee/jline3-demo" target="_blank" rel="noopener">jline3-demo</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，软件的用户界面无非分为 GUI （图形用户界面）和 CLI （命令行用户界面）。对于我们经常使用 Linux 的人来说，命令行界面一定非常熟悉。无论是 Shell 里输入命令的界面，还是如 GDB 等软件的内部交互界面，都是命令行界面。而当我们开发自己的软件，要写认真写一个 CLI 的时候，却发现要手写做出一个好用的命令行界面其实非常困难。因为一个好的命令行界面，在输入/输出之外，还要支持一些常见的命令行功能。&lt;/p&gt;
&lt;p&gt;对我而言，一个合格的命令行软件界面应该支持这三个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动补全：当按下 TAB 键时，在当前光标处进行内容补全。根据上下文信息，补全可能是对命令的补全，也可能是对文件路径的补全。&lt;/li&gt;
&lt;li&gt;命令历史：当按上/下方向键时，可以显示上一条/下一条命令。&lt;/li&gt;
&lt;li&gt;行编辑 (line editing)：可以使用 Emacs 快捷键进行行内的编辑功能，例如 Ctrl+A 移动光标至行首，Ctrl+E 移动光标至行尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;熟悉 Linux 的人会发现，上面这三个功能都是 &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Readline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GNU Readline&lt;/a&gt; 的功能。我们不需要在软件中手写这几个功能，只要用这样一个库就可以了。实际上，GNU/Linux 中使用 GNU Readline 库的软件非常多，这使得 GNU Readline 同时也成为了一个事实上的命令行交互标准。GNU Readline 是 C 语言的库。我们用其他语言的时候，就要找对应功能的库（这往往是封装了底层的 GNU Readline 的库）。对 Java 语言来说，&lt;a href=&quot;https://github.com/jline/jline3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JLine&lt;/a&gt; 就是这样一个帮助你搭建一个命令行交互界面的库。&lt;/p&gt;
&lt;p&gt;本文是想通过一个例子介绍 JLine3 的基本用法。JLine3 并没有一个 “Hello, world!” 的例子，它的 &lt;a href=&quot;https://github.com/jline/jline3/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wiki&lt;/a&gt; 也写得非常简略。虽然有一个示例的程序 &lt;a href=&quot;https://github.com/jline/jline3/blob/master/builtins/src/test/java/org/jline/example/Example.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Example.java&lt;/a&gt;，但这个示例比较复杂，难以理解。希望本文的内容能对你理解 JLine3 的用法有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;基本框架&quot;&gt;&lt;a href=&quot;#基本框架&quot; class=&quot;headerlink&quot; title=&quot;基本框架&quot;&gt;&lt;/a&gt;基本框架&lt;/h2&gt;&lt;p&gt;我们尝试为软件 Fog 设计一个命令行用户界面。用户可以输入四种命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE [FILE_NAME]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OPEN [FILE_NAME] AS [FILE_VAR]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WRITE TIME|DATE|LOCATION TO [FILE_VAR]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLOSE [FILE_VAR]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>GDB 自动化调试</title>
    <link href="http://yoursite.com/posts/2018/GDB-automated-debugging/"/>
    <id>http://yoursite.com/posts/2018/GDB-automated-debugging/</id>
    <published>2018-06-05T17:15:35.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常都是在交互模式下使用 GDB 的，即手动输入各种 GDB 命令。其实 GDB 也支持执行预先写好的调试脚本，进行自动化的调试。调试脚本由一系列的 GDB 命令组成，GDB 会顺序执行调试脚本中的命令。</p><p>编写调试脚本时必须要处理好断点的问题。在交互模式下，程序执行至脚本时，GDB 会等待用户输入下一步的命令。如何在脚本中定义断点触发时进行的操作？这需要一种类似回调函数的机制。</p><p>GDB 中使用 <strong>Breakpoint Command Lists</strong> 的机制来实现这一点。用户可以定义，当程序停在某个 breakpoint (或 watchpoint, catchpoint) 时，执行由 <code>command-list</code> 定义的一系列命令。其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands [list…]</span><br><span class="line">… command-list …</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>例如，我想在每次进入 <code>foo</code> 函数且其参数 <code>x</code> &gt; 0 时打印 <code>x</code> 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">break foo if x&gt;0</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">printf &quot;x is %d\n&quot;,x</span><br><span class="line">continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里有几点要注意的：</p><ul><li>Breakpoint command list 中的第一个命令通常是 <code>silent</code>。这会让断点触发是打印的消息尽量精简。如果 <code>command … end</code> 中没有 <code>printf</code> 之类的打印语句，断点触发时甚至不会产生任何输出。</li><li>Breakpoint command list 中的最后一个命令通常是 <code>continue</code>。这样程序不会在断点处停下，自动化调试脚本可以继续执行。</li></ul><p>GDB 运行自动化调试脚本的方式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [program] -batch -x [commands_file] &gt; log</span><br></pre></td></tr></table></figure><p>其中 <code>-batch</code> 参数将 GDB 运行为脚本模式（不进入交互环境），<code>-x</code> 参数 (也可以写为 <code>-command</code>) 指定调试脚本文件。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">GDB User Manual</a></li><li><a href="https://segmentfault.com/a/1190000005367875" target="_blank" rel="noopener">GDB 自动化操作的技术</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们通常都是在交互模式下使用 GDB 的，即手动输入各种 GDB 命令。其实 GDB 也支持执行预先写好的调试脚本，进行自动化的调试。调试脚本由一系列的 GDB 命令组成，GDB 会顺序执行调试脚本中的命令。&lt;/p&gt;
&lt;p&gt;编写调试脚本时必须要处理好断点的问题。在交互模式下
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 实现 Github Pages + Hexo 博客的自动部署</title>
    <link href="http://yoursite.com/posts/2018/Travis-Hexo-blog-automatic-deploy/"/>
    <id>http://yoursite.com/posts/2018/Travis-Hexo-blog-automatic-deploy/</id>
    <published>2018-05-31T09:59:24.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Hexo 写博客的时候，每次总是要使用 <code>hexo deploy</code> 将博客部署到 GitHub Pages，然后在把博客的源文件 push 到自己的 GitHub repo 里。我之前使用了 Git 分支的方法将博客源文件和博客部署文件放在一个 repo 里（<a href="/posts/2016/Two-Branch-Managing-Blog/">这里</a>）。但是有没有一种方法能让我每次只需要 push 一次呢？答案是有的，那就是使用 Travis CI 持续集成工具。</p><p>Travis CI 最普通的用法是用来做自动测试。每次你 push 到 GitHub repo 的时候，Travis 会自动执行单元测试，这样你就可以知道自己的每个 commit 是否可以通过 build。在发起 pull request 的时候，Travis 也会自动执行待合并分支的单元测试。不过 Travis 能做的事情不止这些，它同样可以实现自动部署，就比如我想要的 GitHub Pages 自动部署。</p><p>Travis CI 会执行用户定义的 <code>.travis.yml</code> 脚本。我想在这个脚本中实现：使用 Hexo 生成博客内容，再将博客内容部署到 <a href="https://github.com/nettee/nettee.github.io/tree/master" target="_blank" rel="noopener">nettee.github.io 项目的 master 分支</a> 上。</p><h3 id="生成博客内容"><a href="#生成博客内容" class="headerlink" title="生成博客内容"></a>生成博客内容</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/nettee/hexo-theme-next</span> <span class="string">themes/next</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><code>.travis.yml</code> 脚本中首先定义了项目语言 (Node.js)，并指定了 Node.js 的版本。<code>install</code> 和 <code>before_script</code> 进行一些 build 前的准备工作。<code>npm install</code> 安装 <code>package.json</code> 文件中定义的项目依赖（Hexo 一系列的依赖）。由于我使用 NexT 主题，并且将 themes/next 作为嵌套 Git 项目，这里还需要将这个项目 clone 下来。</p><p><code>script</code> 定义了真正的 build 过程。由于前面安装好了 Hexo 相关依赖，这里直接调用平时使用的 Hexo 脚本即可。</p><h3 id="部署博客内容"><a href="#部署博客内容" class="headerlink" title="部署博客内容"></a>部署博客内容</h3><p>在日常的使用中，我们使用 <code>hexo deploy</code> 命令来将项目部署到 GitHub Pages 上。但是，由于 <code>.travis.yml</code> 脚本执行在 Travis 的虚拟机中，我们还需要为其配置 SSH。更方便的做法是直接将 public 目录下的内容 push 到 <a href="https://github.com/nettee/nettee.github.io/tree/master" target="_blank" rel="noopener">nettee.github.io 项目的 master 分支</a> 上。这一过程可以使用 GitHub personal token 进行认证。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/nettee/hexo-theme-next</span> <span class="string">themes/next</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"nettee"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"nettee.liu@gmail.com"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Deploy blog pages"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@github.com/nettee/nettee.github.io"</span> <span class="attr">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">blog</span></span><br></pre></td></tr></table></figure><p>脚本中的 <code>GH_TOKEN</code> 是你在 GitHub 上获取的 personal access token。这个 token 需要配置在 Travis 的环境变量中，而不是直接写在 <code>.travis.yml</code> 脚本里。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/5e74046e7a0f" target="_blank" rel="noopener">使用 Travis CI 自动部署 Hexo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Hexo 写博客的时候，每次总是要使用 &lt;code&gt;hexo deploy&lt;/code&gt; 将博客部署到 GitHub Pages，然后在把博客的源文件 push 到自己的 GitHub repo 里。我之前使用了 Git 分支的方法将博客源文件和博客部署文件放在一个 repo 里（&lt;a href=&quot;/posts/2016/Two-Branch-Managing-Blog/&quot;&gt;这里&lt;/a&gt;）。但是有没有一种方法能让我每次只需要 push 一次呢？答案是有的，那就是使用 Travis CI 持续集成工具。&lt;/p&gt;
&lt;p&gt;Travis CI 最普通的用法是用来做自动测试。每次你 push 到 GitHub repo 的时候，Travis 会自动执行单元测试，这样你就可以知道自己的每个 commit 是否可以通过 build。在发起 pull request 的时候，Travis 也会自动执行待合并分支的单元测试。不过 Travis 能做的事情不止这些，它同样可以实现自动部署，就比如我想要的 GitHub Pages 自动部署。&lt;/p&gt;
&lt;p&gt;Travis CI 会执行用户定义的 &lt;code&gt;.travis.yml&lt;/code&gt; 脚本。我想在这个脚本中实现：使用 Hexo 生成博客内容，再将博客内容部署到 &lt;a href=&quot;https://github.com/nettee/nettee.github.io/tree/master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nettee.github.io 项目的 master 分支&lt;/a&gt; 上。&lt;/p&gt;
&lt;h3 id=&quot;生成博客内容&quot;&gt;&lt;a href=&quot;#生成博客内容&quot; class=&quot;headerlink&quot; title=&quot;生成博客内容&quot;&gt;&lt;/a&gt;生成博客内容&lt;/h3&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;language:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;node_js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;node_js:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;stable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;install:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;install&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;before_script:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;https://github.com/nettee/hexo-theme-next&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;themes/next&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;script:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;hexo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;clean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;hexo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;generate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="CI" scheme="http://yoursite.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 的 Interceptors 与责任链模式</title>
    <link href="http://yoursite.com/posts/2018/OkHttp-Interceptors-and-Chain-of-Responsibility-Pattern/"/>
    <id>http://yoursite.com/posts/2018/OkHttp-Interceptors-and-Chain-of-Responsibility-Pattern/</id>
    <published>2018-05-01T22:53:30.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a>是目前Android最流行的HTTP网络库。从Android 4.4开始，标准库<code>HttpURLConnection</code>的底层实现开始使用OkHttp。OkHttp + Retrofit目前是Android网络请求的主流选择。</p><p>OkHttp的源码有很多可以学习的地方，<a href="https://publicobject.com/2016/07/03/the-last-httpurlconnection/" target="_blank" rel="noopener">这篇文章</a>中介绍了OkHttp代码架构的进化过程。OkHttp当前的代码架构已经相当清晰。其中作为发送网络请求的核心的interceptors，是设计模式中<a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" target="_blank" rel="noopener">责任链模式(Chain-of-responsibility pattern)</a>的一个典型的应用。</p><h2 id="OkHttp-的基本用法"><a href="#OkHttp-的基本用法" class="headerlink" title="OkHttp 的基本用法"></a>OkHttp 的基本用法</h2><p>OkHttp使用<code>Request</code>和<code>Response</code>类对网络请求的输入输出进行建模，使用<code>Call</code>对网络请求的行为进行建模。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()  </span><br><span class="line">    .url(url)</span><br><span class="line">    .header(<span class="string">"Accept"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">Response response = call.execute();  </span><br><span class="line"><span class="keyword">int</span> responseCode = response.code();</span><br></pre></td></tr></table></figure><h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><p><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">Interceptor</a>是OkHttp提供的一个强大的机制。用户使用Interceptor可以对网络请求(call)进行监控、重写或重试。用户通过实现<code>Interceptor</code>接口来创建一个interceptor。例如，下面是一个对request/response记录log的interceptor：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建OkHttp client的时候可以指定使用自定义的interceptors：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>正如interceptor的名字（拦截器）所表达的含义。它可以在网络请求的过程中“拦截”request或response，进行用户自定义的操作。</p><h2 id="Interceptors-chain"><a href="#Interceptors-chain" class="headerlink" title="Interceptors chain"></a>Interceptors chain</h2><p>然而，在OkHttp的内部实现中，interceptors并不仅仅是拦截器这么简单。实际上，OkHttp发送网络请求的一切核心功能，包括建立连接、发送请求、读取缓存等，都是通过interceptors来实现的。这些interceptors在运行的时候彼此协作，构成了一个interceptor chain。</p><p>下面我们结合OkHttp的源码理解interceptor chain的工作方式。无论是同步请求还是异步请求，OkHttp都会进入<code>getResponseWithInterceptorChain()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的每个<code>Interceptor</code>是进行具体工作的模块，包括用户定义的<code>client.interceptors()</code>，负责失败重试以及重定向的 <code>RetryAndFollowUpInterceptor</code>，负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 <code>BridgeInterceptor</code>，负责读取缓存直接返回、更新缓存的 <code>CacheInterceptor</code>，负责和服务器建立连接的 <code>ConnectInterceptor</code>，用户定义的<code>client.networkInterceptors()</code>，和负责向服务器发送请求数据、从服务器读取响应数据的 <code>CallServerInterceptor</code>。</p><p>而<code>Chain</code>类则是辅助interceptors执行的工具类。<code>Chain</code>的构造函数的第5个参数表示<code>index</code>，代表第i个及以后的interceptor是有效的。<code>index</code>的初始值是0，每执行一个interceptor，它的值都会增加1。调用<code>Chain.proceed(Request)</code>时，会从第i个interceptor开始依次执行，最终返回一个response对象。每个<code>interceptor.intercept()</code>方法会调用<code>Chain.proceed()</code>来执行其后的interceptors。这样所有的interceptors可以依次被调用。时序图如下：</p><p><img src="/posts/2018/OkHttp-Interceptors-and-Chain-of-Responsibility-Pattern/uml-seq.png" alt="UML: Interceptors 时序图"></p><h2 id="责任链模式-Chain-of-responsibility-pattern"><a href="#责任链模式-Chain-of-responsibility-pattern" class="headerlink" title="责任链模式 (Chain-of-responsibility pattern)"></a>责任链模式 (Chain-of-responsibility pattern)</h2><p><strong>责任链模式</strong> 包含 <em>命令对象</em> 和一系列实现了相同接口的 <em>处理对象</em> ，这些处理对象相互连接成为一条责任链。每一个处理对象能决定它能处理哪些命令对象，对于它不能处理的命令对象，将会传递给该链中的下一个处理对象。</p><p>在 OkHttp 中，命令对象就是 <code>Request</code> 对象，处理对象就是每一个 <code>Interceptor</code> 对象。每个 interceptor 对 request 进行一些步骤的处理，而将其余的工作交给下一个 interceptor。注意到，责任链中的处理对象如果可以全权处理命令对象，则不需要交给下一个处理对象。OkHttp 中的 <code>CacheInterceptor</code> 也是具有全权处理的能力。如果请求的结果已经缓存，则不需要再交给 <code>ConnectInterceptor</code> 等进行连接服务器、发送请求的处理，直接返回已缓存的 response 即可。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://publicobject.com/2016/07/03/the-last-httpurlconnection/" target="_blank" rel="noopener">The Last HttpURLConnection</a></li><li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OkHttp&lt;/a&gt;是目前Android最流行的HTTP网络库。从Android 4.4开始，标准库&lt;code&gt;HttpURLConnection&lt;/code&gt;的底层实现开始使用OkHttp。OkHttp + Retrofit目前是Android网络请求的主流选择。&lt;/p&gt;
&lt;p&gt;OkHttp的源码有很多可以学习的地方，&lt;a href=&quot;https://publicobject.com/2016/07/03/the-last-httpurlconnection/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;中介绍了OkHttp代码架构的进化过程。OkHttp当前的代码架构已经相当清晰。其中作为发送网络请求的核心的interceptors，是设计模式中&lt;a href=&quot;https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;责任链模式(Chain-of-responsibility pattern)&lt;/a&gt;的一个典型的应用。&lt;/p&gt;
&lt;h2 id=&quot;OkHttp-的基本用法&quot;&gt;&lt;a href=&quot;#OkHttp-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 的基本用法&quot;&gt;&lt;/a&gt;OkHttp 的基本用法&lt;/h2&gt;&lt;p&gt;OkHttp使用&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;Response&lt;/code&gt;类对网络请求的输入输出进行建模，使用&lt;code&gt;Call&lt;/code&gt;对网络请求的行为进行建模。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OkHttpClient client = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; OkHttpClient();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Request request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Request.Builder()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .url(url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .header(&lt;span class=&quot;string&quot;&gt;&quot;Accept&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Call call = client.newCall(request);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Response response = call.execute();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; responseCode = response.code();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Interceptors&quot;&gt;&lt;a href=&quot;#Interceptors&quot; class=&quot;headerlink&quot; title=&quot;Interceptors&quot;&gt;&lt;/a&gt;Interceptors&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/Interceptors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interceptor&lt;/a&gt;是OkHttp提供的一个强大的机制。用户使用Interceptor可以对网络请求(call)进行监控、重写或重试。用户通过实现&lt;code&gt;Interceptor&lt;/code&gt;接口来创建一个interceptor。例如，下面是一个对request/response记录log的interceptor：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之坑：如何让Hexo不渲染某些文件</title>
    <link href="http://yoursite.com/posts/2018/Skip-rendering-files-in-Hexo/"/>
    <id>http://yoursite.com/posts/2018/Skip-rendering-files-in-Hexo/</id>
    <published>2018-04-05T15:57:16.000Z</published>
    <updated>2019-12-17T13:30:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>最近在复习和整理一些计算机学科的知识，知识的提纲整理在了<a href="https://github.com/nettee/iknowledge" target="_blank" rel="noopener">iknowledge</a>项目中。我使用的是gitbook工具，可以生成静态网页的书籍格式，于是我就想把这个也放在我的博客上。</p><p>Hexo博客的基本内容是一些Markdown文件，放在<code>source/_post</code>文件夹下，每个文件对应一篇文章。除此之外，放在<code>source</code>文件夹下的所有开头不是下划线的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下。但是，Hexo默认会渲染所有的HTML和Markdown文件，导致gitbook的相关网页显示出错。</p><p>怎么样避开这个坑呢？如果只有一个HTML文件的话，可以简单地在文件开头加上<code>layout: false</code>一行即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然而gitbook生成的静态网页有十几个HTML文件，显然是不可能使用这种方法的。这时候需要使用<code>skip_render</code>配置。根据<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo文档</a>中的说明，通过在<code>_config.yml</code>配置文件中使用<code>skip_render</code>参数，可以跳过指定文件的渲染。使用方式如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">[games/**,</span> <span class="string">depview/**,</span> <span class="string">knowledge/**]</span></span><br></pre></td></tr></table></figure><p>这里的路径匹配可以使用<a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob 表达式</a>。</p><p>在设置了跳过渲染之后，最好使用<code>hexo clean</code>清除以前的编译结果，保证配置生效。</p><p>可以在<a href="/knowledge/">这里</a>看到我的gitbook书籍的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在复习和整理一些计算机学科的知识，知识的提纲整理在了&lt;a href=&quot;https://github.com/nettee/iknowledge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iknowledge&lt;/a&gt;项目中。我使用的是gitbook工
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Depview: Java程序调用依赖关系的分析与显示</title>
    <link href="http://yoursite.com/posts/2018/Depview-View-invocation-relationships-in-Java-projects/"/>
    <id>http://yoursite.com/posts/2018/Depview-View-invocation-relationships-in-Java-projects/</id>
    <published>2018-01-26T14:33:02.000Z</published>
    <updated>2019-12-17T13:30:12.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DepView"><a href="#DepView" class="headerlink" title="DepView"></a>DepView</h1><p><a href="https://github.com/nettee/DepView" target="_blank" rel="noopener">DepView</a>这个工具来自程序分析课上的一个小作业，而它的灵感来自我平时读别人代码的时候。例如我前一阵子就拿到了师兄的项目源码，一共100个Java文件，11k行代码。如何理解一个项目的代码呢？首先我们想到通过读文档、注释来理解，但师兄的项目显然是没有文档也没有注释的。或者我也可以直接向师兄请教，但师兄可能已经记不清他几个月前写代码时的思路了。于是，在很多时候，我们理解一个项目的方式只能是通过直接阅读代码，正是所谓的”Read the fucking source code”。那么，能否有一个工具来辅助我理解代码呢？</p><h2 id="理解一个项目的关键点"><a href="#理解一个项目的关键点" class="headerlink" title="理解一个项目的关键点"></a>理解一个项目的关键点</h2><p>哪些关键信息可以帮助我们很好地理解代码呢？</p><p>第一种关键信息是代码的基本使用模式，或者叫做用例。通过用例我们可以很快知道哪些模块是对外的接口，这些模块应该是我们首先关注的。如果一个项目有测试代码，而且写得比较好的话，那么通过看测试用例就可以很快知道代码的使用模式。</p><p>第二种关键信息是模块间的协作关系。很多时候程序的逻辑分散在不同的模块中，很难梳理。如果能够知道模块间的相互关系，就可以很方便地梳理程序脉络。这可以用工具来完成。我希望有一个工具能够显示模块间的依赖关系，包括：找到程序入口（模块入口），以及找出紧密协作的模块。Depview实现的是<strong>调用依赖关系</strong>的分析与显示。因为调用依赖关系容易定义，而且可以比较好地体现上下层模块间的关系。</p><h2 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h2><p>Depview的工作步骤可以分为分析和显示两个部分。它首先解析源代码生成抽象语法树，在抽象语法树上提取依赖关系，最后绘制依赖图。</p><p><img src="/posts/2018/Depview-View-invocation-relationships-in-Java-projects/overview.png" alt="Figure: overview"></p><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Depview分析的是一个Java项目。为了分析的需要，它同时需要Java项目的源代码和编译后的字节码。由于Java项目通常依赖众多，用户还可以根据需要，将依赖也一起进行分析。为了方便输入，Depview支持用户使用一个描述文件，其中描述了该Java项目的源代码、字节码，和相关依赖。描述文件使用的格式是<a href="https://github.com/lightbend/config" target="_blank" rel="noopener">HOCON</a>，一种类似JSON，但更易读易写的格式。描述文件示例如下，其中大部分路径支持项目内相对路径，依赖支持Jar依赖和Maven依赖，Depview会从本地Maven仓库里拷贝出相应的Jar文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">testSubject</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span> <span class="string">=</span> <span class="string">DepView</span></span><br><span class="line">    <span class="string">package</span> <span class="string">=</span> <span class="string">me.nettee.depview</span></span><br><span class="line">    <span class="string">path</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">base</span> <span class="string">=</span> <span class="string">/home/william/projects/depview</span></span><br><span class="line">        <span class="string">sources</span> <span class="string">=</span> <span class="string">[</span> <span class="string">src/main/java</span> <span class="string">]</span></span><br><span class="line">        <span class="string">classes</span> <span class="string">=</span> <span class="string">[</span> <span class="string">target/classes</span> <span class="string">]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">dependency.jar</span> <span class="string">=</span> <span class="string">[</span></span><br><span class="line">        <span class="string">libs/fastjson-1.2.16.jar</span></span><br><span class="line">        <span class="string">libs/guava-19.0.jar</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">    <span class="string">dependency.maven</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">repository</span> <span class="string">=</span> <span class="string">/home/william/.m2/repository</span></span><br><span class="line">        <span class="string">jar</span> <span class="string">=</span> <span class="string">[</span></span><br><span class="line">            <span class="string">config-1.3.1.jar</span></span><br><span class="line">            <span class="string">commons-lang3-3.7.jar</span></span><br><span class="line">        <span class="string">]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>Depview使用Eclipse JDT工具来将Java代码解析成抽象语法树。主要使用了<code>ASTParser</code>, <code>ASTNode</code>, <code>ASTVisitor</code>相关API，参见<a href="https://help.eclipse.org/neon/index.jsp?topic=/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/package-summary.html&amp;resultof=%22ASTParser%22%20%22astpars%22" target="_blank" rel="noopener">Eclipse JDT相关文档</a>。这个工具需要同时提供source path和class path，其中class path包括项目的字节码和依赖库。</p><p>Eclipse JDT工具我在几年前就用过，但当时还不知道Maven，不理解依赖管理工具的重要性，都是从Eclipse的安装目录下拷贝jar文件到项目里作为依赖的。而且Eclipse JDT工具究竟要使用哪些Maven依赖也不太清楚。直到上次写AST相似度比较的项目，我才参考<a href="http://www.shenyanchao.cn/blog/2013/06/19/use-eclipse-ast-to-parser-java/" target="_blank" rel="noopener">这篇博文</a>确定了Maven依赖项。事实证明使用Maven管理确实超级方便，而且在这个项目中帮助我跳出了一个大坑。后面细说。</p><h3 id="提取依赖关系"><a href="#提取依赖关系" class="headerlink" title="提取依赖关系"></a>提取依赖关系</h3><p>Depview通过遍历所有的抽象语法树来提取调用依赖关系。遍历可以通过继承<code>ASTVisitor</code>类，使用<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">访问者模式</a>来遍历抽象语法树。</p><p>一个调用依赖关系包括三个元素：起始类，目标类，和调用表达式。首先，遍历是从每个<strong>类定义</strong>(<code>TypeDeclaration</code>)结点开始的。这个结点下面所有的调用依赖都以这个类为起始类。在遍历的过程中，寻找<strong>方法调用</strong>(<code>MethodInvocation</code>)结点。方法调用的形式一般为<code>expression.ID(args)</code>，提取<code>expression</code>的类型名作为目标类。</p><p>提取<code>expression</code>的类型需要使用JDT的binding功能。在测试的过程中我发现JDT对于接近一半的依赖关系无法得到binding，导致近一半的依赖关系无法提取，这会导致依赖图非常不完整。经过不断尝试，我发现新版本的JDT可以解析出绝大部分的binding。最终我使用的JDT版本（Maven依赖）为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.core.runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.core.resources<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.100<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.tycho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jdt.core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.2.v20161117-1814<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我不禁想，如果不是使用Maven，而是直接导入jar文件的话，我就算能想到版本不对的问题，也无法解决了。</p><h3 id="依赖关系图"><a href="#依赖关系图" class="headerlink" title="依赖关系图"></a>依赖关系图</h3><p>我将依赖关系图使用有向图建模，以类作为结点，依赖关系作为有向边。这个图允许平行边，用来表示两个类之间存在多条调用的情况；但不允许环，即忽略一个类对自身的调用。此外默认排除了标准库和第三库的依赖。有向图数据结构使用<a href="https://github.com/google/guava/wiki/GraphsExplained" target="_blank" rel="noopener">Guava</a>的<code>Network</code>类。</p><h3 id="依赖图可视化"><a href="#依赖图可视化" class="headerlink" title="依赖图可视化"></a>依赖图可视化</h3><p>我选择基于D3.js的<a href="https://bl.ocks.org/mbostock/4062045" target="_blank" rel="noopener">Force-directed Graph</a>作为可视化方式。Neo4j数据库也是使用这种方法进行可视化的。这个图是使用“力”的概念对图进行显示的，其中边类似于弹簧，提供向内的拉力；结点类似带点粒子，互相之间存在斥力。这个图会对结点进行重新排布，有利于减少图中边的交叉。此外它是可拖拽的，交互性比较好。我将原先依赖关系图中的平行边变为边的权重，这样依赖关系越多的两个类之间的权重越大，之间的拉力也会变大。</p><p>使用这个图的时候要注意：如果两个结点之间不存在依赖关系，一定不要设置边，即使权重为零也不行！我一开始忽略了这一点，导致所有的边缠成了毛线球的样子，还以为是自己的图哪里搞错了。</p><p>最终得到的依赖图如下。可以到<a href="/depview/">这里</a>尝试一下拖拽效果。</p><p><img src="/posts/2018/Depview-View-invocation-relationships-in-Java-projects/depgraph.png" alt="Figure: depencendy graph"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DepView&quot;&gt;&lt;a href=&quot;#DepView&quot; class=&quot;headerlink&quot; title=&quot;DepView&quot;&gt;&lt;/a&gt;DepView&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nettee/DepView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DepView&lt;/a&gt;这个工具来自程序分析课上的一个小作业，而它的灵感来自我平时读别人代码的时候。例如我前一阵子就拿到了师兄的项目源码，一共100个Java文件，11k行代码。如何理解一个项目的代码呢？首先我们想到通过读文档、注释来理解，但师兄的项目显然是没有文档也没有注释的。或者我也可以直接向师兄请教，但师兄可能已经记不清他几个月前写代码时的思路了。于是，在很多时候，我们理解一个项目的方式只能是通过直接阅读代码，正是所谓的”Read the fucking source code”。那么，能否有一个工具来辅助我理解代码呢？&lt;/p&gt;
&lt;h2 id=&quot;理解一个项目的关键点&quot;&gt;&lt;a href=&quot;#理解一个项目的关键点&quot; class=&quot;headerlink&quot; title=&quot;理解一个项目的关键点&quot;&gt;&lt;/a&gt;理解一个项目的关键点&lt;/h2&gt;&lt;p&gt;哪些关键信息可以帮助我们很好地理解代码呢？&lt;/p&gt;
&lt;p&gt;第一种关键信息是代码的基本使用模式，或者叫做用例。通过用例我们可以很快知道哪些模块是对外的接口，这些模块应该是我们首先关注的。如果一个项目有测试代码，而且写得比较好的话，那么通过看测试用例就可以很快知道代码的使用模式。&lt;/p&gt;
&lt;p&gt;第二种关键信息是模块间的协作关系。很多时候程序的逻辑分散在不同的模块中，很难梳理。如果能够知道模块间的相互关系，就可以很方便地梳理程序脉络。这可以用工具来完成。我希望有一个工具能够显示模块间的依赖关系，包括：找到程序入口（模块入口），以及找出紧密协作的模块。Depview实现的是&lt;strong&gt;调用依赖关系&lt;/strong&gt;的分析与显示。因为调用依赖关系容易定义，而且可以比较好地体现上下层模块间的关系。&lt;/p&gt;
&lt;h2 id=&quot;工作步骤&quot;&gt;&lt;a href=&quot;#工作步骤&quot; class=&quot;headerlink&quot; title=&quot;工作步骤&quot;&gt;&lt;/a&gt;工作步骤&lt;/h2&gt;&lt;p&gt;Depview的工作步骤可以分为分析和显示两个部分。它首先解析源代码生成抽象语法树，在抽象语法树上提取依赖关系，最后绘制依赖图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/2018/Depview-View-invocation-relationships-in-Java-projects/overview.png&quot; alt=&quot;Figure: overview&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统复习</title>
    <link href="http://yoursite.com/posts/2017/Distributed-Systems-Review/"/>
    <id>http://yoursite.com/posts/2017/Distributed-Systems-Review/</id>
    <published>2017-12-25T14:41:50.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统模型"><a href="#分布式系统模型" class="headerlink" title="分布式系统模型"></a>分布式系统模型</h1><h2 id="什么是分布式系统-01-8"><a href="#什么是分布式系统-01-8" class="headerlink" title="什么是分布式系统 [01-8]"></a>什么是分布式系统 [01-8]</h2><p>A distributed system is a collection of <strong>autonomous(自治的) computing elements</strong> that appears to its users as a <strong>single coherent(一致的) system</strong>.</p><ul><li>每个计算单元(机器/进程)可以独立地工作（但他们通过通信相互协作）</li><li>用户(人或应用)认为他面对的是一个单一系统（分布式透明性）</li></ul><h2 id="为什么要分布式-01-11"><a href="#为什么要分布式-01-11" class="headerlink" title="为什么要分布式? [01-11]"></a>为什么要分布式? [01-11]</h2><ul><li>Economic: 微处理器比大型机性价比高</li><li>Speed: 分布式系统整个计算能力比单个大型主机要强 ==&gt; Performance</li><li>Inherent(固有的) distribution: 有些应用涉及到空间上分散的机器</li><li>Reliability: 如果其中一台机器崩溃,整体系统仍然能够运转 ==&gt; Availability</li><li>Incremental growth: 计算能力可以逐渐有所增加 ==&gt; Scalability</li></ul><h2 id="分布式系统的目标-01-12"><a href="#分布式系统的目标-01-12" class="headerlink" title="分布式系统的目标 [01-12]"></a>分布式系统的目标 [01-12]</h2><p>（构建分布式系统的时候应该努力达成的重要目标）</p><p>“ATOS”</p><ul><li>Making resources <strong>available</strong> 可用性<ul><li>用户易于访问, 易于共享</li></ul></li><li><strong>Transparency</strong> 透明性: Hide the fact that resources are distributed</li><li><strong>Openness</strong> 开放性</li><li><strong>Scalability</strong> 可扩展性<ul><li><strong>size scalability</strong>: 可以容易地添加用户/资源，而没有显著的性能损失</li><li><strong>geographical scalability</strong>: 用户/资源可能距离很远，但没有显著的通信延迟</li><li><strong>administrative scalability</strong>: An administratively scalable system is one that can still be easily managed even if it spans many independent administrative organizations. 即使跨越许多独立的行政组织，仍然可以轻松管理</li><li>大部分系统可以做到第一点，但后两点很难做到</li></ul></li></ul><a id="more"></a><h2 id="分布式系统透明性和开放性的含义"><a href="#分布式系统透明性和开放性的含义" class="headerlink" title="分布式系统透明性和开放性的含义"></a>分布式系统透明性和开放性的含义</h2><h3 id="透明性-01-13-P8"><a href="#透明性-01-13-P8" class="headerlink" title="透明性 [01-13] [P8]"></a>透明性 [01-13] [P8]</h3><ul><li>Access<ul><li>Hide differences in data representation and how a resource is accessed: 数据在不同的机器上如何表示</li></ul></li><li>Location<ul><li>Hide where a resource is located: 机器/资源的物理位置</li></ul></li><li>Relocation<ul><li>Hide that a resource may be moved to another location while in use (被动移动): 云计算中很重要</li></ul></li><li>Migration<ul><li>Hide that a resource may move to another location (主动移动): 如移动通信</li></ul></li><li>Replication<ul><li>Hide that a resource may be shared by several competitive users</li></ul></li><li>Concurrency<ul><li>Hide that a resource may be shared by several competitive users: 并发访问时需要保持资源的一致性状态</li></ul></li><li>Failure<ul><li>Hide the failure and recovery of a resource: 用户察觉不到故障以及后续的修复过程</li></ul></li></ul><h3 id="开放性-01-15-P12"><a href="#开放性-01-15-P12" class="headerlink" title="开放性 [01-15] [P12]"></a>开放性 [01-15] [P12]</h3><ul><li>(Textbook p.12) An <strong>open</strong> distributed system is essentially a system that offers components that can easily be used by, or integrated into other systems.<br>提供的组件可以很容易地被其他系统使用或集成</li><li>灵活性 flexibility</li><li>可以更换一个组件而不影响整个系统</li><li>策略(policy)与机制(mechanism)分离：策略具体，机制抽象</li></ul><h2 id="分布式系统构成方法"><a href="#分布式系统构成方法" class="headerlink" title="分布式系统构成方法"></a>分布式系统构成方法</h2><p>分为：分布式操作系统(DOS)、网络操作系统(NOS)和基于中间件的系统(Middleware)</p><ul><li>分布式操作系统(DOS)<ul><li>具有较好的透明性和易用性，但没有对相互独立的计算机集合的操作处理能力</li></ul></li><li>网络操作系统(NOS)<ul><li>有良好的可扩展性和开放性，但对透明性和易用性比较差</li></ul></li><li>基于中间件的系统(Middleware)<ul><li>在网络操作系统之上增加一个中间层，屏蔽各底层平台之间的异构性，增加透明性和易用性</li></ul></li></ul><p>DOS 不是管理一组独立的计算机，NOS 也没有提供单个一致的系统，因此都不是分布式系统</p><p>???</p><h2 id="分布式系统的类型-01-19"><a href="#分布式系统的类型-01-19" class="headerlink" title="分布式系统的类型 [01-19]"></a>分布式系统的类型 [01-19]</h2><ul><li>Distributed computing systems<ul><li>Cluster Computing</li><li>Grid Computing</li><li>Cloud Computing</li></ul></li><li>Distributed information systems<ul><li>Transaction processing systems</li></ul></li><li>Distributed pervasive systems (next-generation)<ul><li>Mobile computing systems</li><li>Sensor networks</li></ul></li></ul><h1 id="分布式系统架构"><a href="#分布式系统架构" class="headerlink" title="分布式系统架构"></a>分布式系统架构</h1><h2 id="分布式系统架构风格-02-3-4"><a href="#分布式系统架构风格-02-3-4" class="headerlink" title="分布式系统架构风格 [02-3~4]"></a>分布式系统架构风格 [02-3~4]</h2><ul><li>Organize into logically different components, and distribute those components over the various machines.</li><li>Decoupling processes in space (“anonymous”) and also time (“asynchronous”) has led to alternative styles.</li></ul><p>(Textbook p.56) 使用<strong>component</strong>和<strong>connector</strong>定义，有四种典型类型：</p><ul><li>Layered architectures</li><li>Object-based architectures</li><li>Resource-centered architectures</li><li>Event-based architectures</li></ul><h2 id="分布式系统组织形式-02-5"><a href="#分布式系统组织形式-02-5" class="headerlink" title="分布式系统组织形式 [02-5]"></a>分布式系统组织形式 [02-5]</h2><ul><li><strong>Centralized</strong>: 基本的 Client/Server 模型</li><li><strong>Decentralized</strong>: Peer-to-peer (P2P)</li><li><strong>Hybrid</strong>: Client/Server combined with P2P</li></ul><h2 id="客户-服务器模式和对等模式"><a href="#客户-服务器模式和对等模式" class="headerlink" title="客户-服务器模式和对等模式"></a>客户-服务器模式和对等模式</h2><ul><li>Client-Server 模式是 <strong>vertical distribution</strong>，将不同逻辑功能的 component 划分到不同的机器上</li><li>P2P 模式是 <strong>horizontal distribution</strong>，每个机器的功能都是等价的</li></ul><h3 id="Client-Server-模式-02-6"><a href="#Client-Server-模式-02-6" class="headerlink" title="Client-Server 模式 [02-6]"></a>Client-Server 模式 [02-6]</h3><p>Request/Response 模型</p><ul><li>Multiple client / Single server</li><li>Multiple client / Multiple server</li></ul><p>经典的三层架构：</p><ul><li>user interface layer</li><li>processing layer</li><li>data layer</li></ul><p>多层架构（对于机器而言）</p><ul><li>(Physically) two-tiered architecture: client machine &amp; server machine<ul><li>一般将 user interface layer 放在 client machine 上，将 processing layer 和 data layer放在 server machine 上</li></ul></li><li>(Physically) three-tiered architecture: client machine, application server &amp; database server.</li></ul><h3 id="对等-P2P-模式-02-21"><a href="#对等-P2P-模式-02-21" class="headerlink" title="对等 (P2P) 模式 [02-21]"></a>对等 (P2P) 模式 [02-21]</h3><ul><li>Structured P2P: 有特定的拓扑结构，如环、二叉树、网格<ul><li>找一个数据只要找特定ID的结点即可</li></ul></li><li>Unstructured P2P: nodes have randomly selected neighbors<ul><li>search 方法：<ul><li>Flooding</li><li>Random walk</li></ul></li><li>Super peers: weak peer 通过 super peers 来通信</li></ul></li><li>Hybrid P2P: some nodes are appointed special functions in a well-organized fashion<ul><li><strong>Edge-server systems</strong></li><li>BitTorrent</li></ul></li></ul><h2 id="将分布式系统组织为中间件-02-28-P71"><a href="#将分布式系统组织为中间件-02-28-P71" class="headerlink" title="将分布式系统组织为中间件 [02-28] [P71]"></a>将分布式系统组织为中间件 [02-28] [P71]</h2><ul><li>上面讨论的都是高层的架构, 而中间件是一个具体的组织形式</li><li>中间件的目标: 实现开放性</li><li>中间件常用的两个设计模式: wrappers 和 interceptors<ul><li>wrapper/adapter: 为某个组件提供接口, 解决了接口不兼容的问题<ul><li>broker 模式用来将 adapter 的数量由 m*n 减少为 m+n</li></ul></li><li>interceptor: 在正常的控制流(通常是RPC请求过程)中插入一段代码</li><li>通常用于改造中间件, 以满足应用的实际需求</li></ul></li></ul><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>什么是进程：</p><ul><li>Program: Static code and static data</li><li>Process: Dynamic instance of code and data</li></ul><p>线程是轻量级的进程：</p><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程</li><li>进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位</li><li>线程不拥有存储资源，同一进程的所有线程共享该进程的所有资源</li></ul><h2 id="代码迁移-03-31"><a href="#代码迁移-03-31" class="headerlink" title="代码迁移 [03-31]"></a>代码迁移 [03-31]</h2><ul><li>迁移代码通常是为了性能考虑</li><li>迁移虚拟机比迁移代码要容易很多</li><li>同构系统中, 假设迁移后的代码可以直接运行</li></ul><h3 id="迁移内容"><a href="#迁移内容" class="headerlink" title="迁移内容"></a>迁移内容</h3><ul><li><strong>Code segment</strong>: contains the actual code</li><li><strong>Data segment</strong>: contains the state</li><li><strong>Execution state</strong>: contains context of thread executing the object’s code</li></ul><h3 id="强迁移-vs-弱迁移-03-32"><a href="#强迁移-vs-弱迁移-03-32" class="headerlink" title="强迁移 vs. 弱迁移 [03-32]"></a>强迁移 vs. 弱迁移 [03-32]</h3><ul><li>弱迁移<ul><li>只迁移 code segment &amp; data segment</li><li>一定重启</li><li>最后被目标进程或者另外一个独立的进程执行</li></ul></li><li>强迁移<ul><li>迁移 code segment, data segment &amp; execution state</li><li>要么复制进程 (正在执行的进程停下来，移动后再恢复)</li><li>要么克隆 (所有数据完全复制到另外一台机器上，和原来的进程并行)</li><li>Migration: move entire object from one machine to the other</li><li>Cloning: start a clone, and set it in the same execution state</li></ul></li></ul><h3 id="迁移和本地资源"><a href="#迁移和本地资源" class="headerlink" title="迁移和本地资源"></a>迁移和本地资源</h3><ul><li>对象使用可能在目标站点可用或不可用的本地资源</li><li>资源类型<ul><li>固定资源 Fixed：资源不能迁移，如本地硬件</li><li>捆绑资源 Fastened：资源原则上可以迁移，但成本很高</li><li>独立资源 Unattached：资源可以轻松地随对象一起移动（例如缓存）</li></ul></li><li>对象到资源绑定<ul><li>通过标识符：对象需要资源的特定实例（例如特定数据库）</li><li>按值：对象需要资源的值（例如，缓存实体集合）</li><li>按类型：对象要求只有一种类型的资源可用（例如，颜色监视器）</li></ul></li></ul><h3 id="在异构系统中的迁移-P158"><a href="#在异构系统中的迁移-P158" class="headerlink" title="在异构系统中的迁移 [P158]"></a>在异构系统中的迁移 [P158]</h3><ul><li>主要问题<ul><li>目标计算机可能不适合执行迁移的代码</li><li>进程/线程/处理器上下文的定义高度依赖于本地硬件，操作系统和运行时系统</li></ul></li><li>利用在不同平台上实现的抽象机<ul><li>解释语言，有效地拥有自己的 VM</li><li>虚拟机</li></ul></li></ul><p>将计算环境与底层系统解耦</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="通信的类型-P172"><a href="#通信的类型-P172" class="headerlink" title="通信的类型 [P172]"></a>通信的类型 [P172]</h2><p>见“基于消息的通信”</p><h2 id="远程过程调用-RPC"><a href="#远程过程调用-RPC" class="headerlink" title="远程过程调用(RPC)"></a>远程过程调用(RPC)</h2><h3 id="RPC的工作过程-04-1-16"><a href="#RPC的工作过程-04-1-16" class="headerlink" title="RPC的工作过程 [04-1-16]"></a>RPC的工作过程 [04-1-16]</h3><ol><li>The client procedure calls the client stub in the normal way.</li><li>The client stub builds a message and calls the local operating system.</li><li>The client’s OS sends the message to the remote OS.</li><li>The remote OS gives the message to the server stub.</li><li>The server stub unpacks the parameter(s) and calls the server.</li><li>The server does the work and returns the result to the stub.</li><li>The server stub packs the result in a message and calls its local OS.</li><li>The server’s OS sends the message to the client’s OS.</li><li>The client’s OS gives the message to the client stub.</li><li>The stub unpacks the result and returns it to the client.</li></ol><p>Client –(1)-&gt; Client stub -(2)-&gt; Client OS -(3)-&gt; Server OS -(4)-&gt; Server stub (5)-&gt; Server</p><p>Client &lt;-(10)- Client stub &lt;-(9)- Client OS &lt;-(8)- Server OS &lt;-(7)- Server stub &lt;-(6)- Server</p><h3 id="故障处理-P464-04-1-20"><a href="#故障处理-P464-04-1-20" class="headerlink" title="故障处理 [P464] [04-1-20]"></a>故障处理 [P464] [04-1-20]</h3><p>五种 failure:</p><ol><li>Client cannot locate the server<ul><li>Reason: 服务器宕机，服务器接口更新</li><li>Solution: Throw an exception，或使用特殊的返回值</li></ul></li><li>Lost request messages<ul><li>超时则重新request</li><li>对于不幂等的请求，编上序号让server能识别重复请求</li></ul></li><li>Server crashes<ul><li>两种情况: Execute之前Crash，Execute之后Crash</li><li>难以解决<ul><li>重启server并重新进行处理：保证至少执行一次(at-least-once)</li><li>立即放弃并报告错误：保证至多执行一次(at-most-once)</li><li>什么都不保证</li></ul></li></ul></li><li>Lost reply messages<ul><li>超时则重新request</li><li>对于不幂等的请求，编上序号让server能识别重复请求</li></ul></li><li>Client crashes (orphan 问题)<ul><li><strong>orphan extermination</strong>: 为request记录log，client重启时检查log</li><li><strong>reincarnation</strong>: client重启时广播，停止orphan computations</li><li><strong>gentle reincarnation</strong>: server收到广播时寻找本地computations的owner，找不到则停止computations</li><li><strong>expiration</strong>: 除非另外要求，RPC都要在规定时间内完成</li></ul></li></ol><h3 id="动态绑定-04-1-35"><a href="#动态绑定-04-1-35" class="headerlink" title="动态绑定 [04-1-35]"></a>动态绑定 [04-1-35]</h3><p>（书上没有）</p><ul><li>绑定：一种让 client 找到 server 的方法<ul><li>静态绑定：将server地址硬编码到client代码中 (ip, port)</li></ul></li><li>结构<ul><li>Client/Server/Binder<ul><li>Server 向 Binder 注册/取消注册 </li><li>Client 向 Binder 查找，Binder 返回结果</li><li>Client 调用 Server</li></ul></li></ul></li><li>绑定过程（Client 第一次调用 RPC 时）<ul><li>Server 启动时向 Binder 注册<ul><li>Register 请求，参数：ID、名字、版本、地址</li><li>Unregister 请求，参数：ID、名字、版本</li></ul></li><li>Client stub 向 Binder 查找 Server 接口 <ul><li>Look-up 请求，参数：名字、版本；返回：ID、地址</li></ul></li><li>Client 根据地址发送 RPC 调用</li></ul></li><li>优点<ul><li>灵活性 flexibility</li><li>可以支持多个支持同一接口的服务器，例如：<ul><li>Binder 可以随机地将服务器上的客户端传播到均匀负载（相当于负载均衡器）</li><li>Binder 可以定期轮询服务器，自动取消注册失败的服务器，以达到一定的容错能力</li><li>Binder 可以帮助身份验证</li></ul></li><li>Binder 可以验证客户端和服务器都使用相同版本的接口</li></ul></li><li>缺点<ul><li>导出/导入接口的额外开销花费时间</li><li>binder 可能成为大型分布式系统中的瓶颈</li></ul></li></ul><h2 id="基于消息的通信-04-2"><a href="#基于消息的通信-04-2" class="headerlink" title="基于消息的通信 [04-2]"></a>基于消息的通信 [04-2]</h2><h3 id="持久性-非持久性-瞬时性-P172-04-2-4"><a href="#持久性-非持久性-瞬时性-P172-04-2-4" class="headerlink" title="持久性/非持久性(瞬时性) [P172] [04-2-4]"></a>持久性/非持久性(瞬时性) [P172] [04-2-4]</h3><p>Persistent/transient (reliable/unreliable)</p><ul><li><strong>persistent communication</strong>: a message that has been submitted for transmission is stored by the communication middleware as long as it takes to deliver it to the receiver 通信机制本身会对消息进行持久存储，直到它被传递给目的<ul><li>消息的发送者和接收这不必同时存在（同时处于执行状态），如：电子邮件</li></ul></li><li><strong>transient communication</strong>: a message is stored by the communication system only as long as the sending and receiving application are executing 传输服务仅仅提供临时的对消息的存储<ul><li>一旦发送者退出或者接收者退出，传输就会失败，如：电话</li></ul></li></ul><p>Asynchronous/synchronous (unblocking/blocking) [04-2-3]</p><ul><li><strong>asynchronous communication</strong>: a sender continues immediately after it has submitted its<br>message for transmission</li><li><strong>synchronous communication</strong>: the sender is blocked until its request is known to be accepted<ul><li>synchronize at request submission 直到消息被成功提交给传输服务</li><li>synchronize at request delivery 直到消息被接收者成功接收</li><li>synchronize after processing by server (at response) 直到消息的接收者接收、处理消息、并且处理的结果返回到发送者</li></ul></li></ul><p>[04-2-7] Persistent Messaging Alternatives 这页啥意思？？？</p><h3 id="面向流的通信-Stream-oriented-communication-04-2-16"><a href="#面向流的通信-Stream-oriented-communication-04-2-16" class="headerlink" title="面向流的通信 Stream-oriented communication [04-2-16]"></a>面向流的通信 Stream-oriented communication [04-2-16]</h3><p>连续媒体</p><ul><li>离散媒体：数据项在时间上的联系不重要</li><li>连续媒体 (continuous media)：不同数据项在时间上的联系（对于正确解释数据含义）非常重要，如：音频、视频、动画</li></ul><p>不同的传输模式</p><ul><li>异步传输模式（离散媒体）：没有时间的限制</li><li>同步传输模式（连续媒体）：最大延迟时间</li><li>等时传输模式（连续媒体）：最大延迟时间 &amp; 最小延迟时间</li></ul><p>流与 QoS (Quality of Service)</p><ul><li>利用区分服务为不同类型的数据提供服务</li><li>利用缓冲区减少延时抖动</li><li>交错传输来降低丢包的影响</li></ul><h3 id="Multicast-communication-04-2-26"><a href="#Multicast-communication-04-2-26" class="headerlink" title="Multicast communication [04-2-26]"></a>Multicast communication [04-2-26]</h3><p>不在范围内</p><h1 id="同步与资源管理"><a href="#同步与资源管理" class="headerlink" title="同步与资源管理"></a>同步与资源管理</h1><h2 id="同步问题-06-4"><a href="#同步问题-06-4" class="headerlink" title="同步问题 [06-4]"></a>同步问题 [06-4]</h2><p>为什么要进行同步？</p><ul><li>保证多个进程不会同时访问共享资源 (mutual exclusion)</li><li>保证多个进程可以相互达成一致 (consensus)</li></ul><p>分布式系统的同步与集中式系统有何区别？</p><ul><li>在集中式系统中，同步问题可以通过信号量等方法解决</li><li>但这些方法无法在分布式系统中生效，因为它们隐含地依赖于共享内存的存在</li></ul><h2 id="时钟同步机制-06-5"><a href="#时钟同步机制-06-5" class="headerlink" title="时钟同步机制 [06-5]"></a>时钟同步机制 [06-5]</h2><p>时间不能回退，可以逐渐放快或放慢</p><ul><li>Cristian’s algorithm [06-12] [P304]<ul><li>假设 time server 提供精确时间</li><li>所有机器和 time server 同步</li><li>考虑通信延迟</li></ul></li><li>Berkeley algorithm [06-13] [P306]<ul><li>适用于没有精确时钟的情况</li><li>time daemon 主动询问其他所有机器的时间</li><li>计算平均时间作为标准</li></ul></li><li>Network Time Protocol [06-15] [P304]<ul><li>类似 Cristian’s algorithm 的计算方法</li><li>Stratum-0/1/2/3 server，数字越小越精确</li></ul></li></ul><h2 id="Logical-clocks-逻辑时钟-06-16"><a href="#Logical-clocks-逻辑时钟-06-16" class="headerlink" title="Logical clocks 逻辑时钟 [06-16]"></a>Logical clocks 逻辑时钟 [06-16]</h2><p>很多时候不需要知道精确的时间，只需要知道事件发生的先后关系就可以，这就叫做逻辑时钟</p><h3 id="Lamport’s-logical-clocks-06-18-P310"><a href="#Lamport’s-logical-clocks-06-18-P310" class="headerlink" title="Lamport’s logical clocks [06-18] [P310]"></a>Lamport’s logical clocks [06-18] [P310]</h3><ul><li>定义 Happens-before 关系</li><li>Assigning time C(e) to events，使满足 HB 关系<ul><li>每个进程维护一个 C (分布式)</li><li>调整方法：When a message arrives and the receiver’s clock shows a value prior to the time the message was sent, the receiver fast forwards its clock to be one more than the sending time. C_j = max{ts(m), C_j}</li><li>为 timestamp 添加进程ID(e.g. <40,i>, <40,j>)，防止出现相等的 timestamp</40,j></40,i></li></ul></li><li>缺点<ul><li>通过 C(a) 和 C(b) 不能确定 a 和 b 的 HB 关系 </li><li>根本原因: Lamport’s logical clocks 不包含因果关系(causality)</li></ul></li></ul><h3 id="Vector-clock-向量时戳-06-23-P316"><a href="#Vector-clock-向量时戳-06-23-P316" class="headerlink" title="Vector clock 向量时戳 [06-23] [P316]"></a>Vector clock 向量时戳 [06-23] [P316]</h3><ul><li>原理：记录所有进程的历史信息(causal histories)</li><li>Assign time VC，VC[i] 表示 P_i 发生过的时间数量<ul><li>每个进程维护一个 VC (分布式)</li><li>调整方法同Lamport’s logical clocks</li></ul></li><li>比较方法<ul><li>VC(a) &lt; VC(b) iff. VC(a)[k] &lt;= VC(b)[k] for all k</li></ul></li><li>若 VC(a) &lt; VC(b)，则可以认为 a, b 之间有 causal relationship</li></ul><h2 id="Mutual-exclusion-互斥访问-06-27"><a href="#Mutual-exclusion-互斥访问-06-27" class="headerlink" title="Mutual exclusion 互斥访问 [06-27]"></a>Mutual exclusion 互斥访问 [06-27]</h2><h3 id="A-centralized-algorithm-P322-06-28"><a href="#A-centralized-algorithm-P322-06-28" class="headerlink" title="A centralized algorithm [P322] [06-28]"></a>A centralized algorithm [P322] [06-28]</h3><ul><li>方法<ul><li>使用单个决策进程，称为 coordinator</li><li>请求资源的进程向 coordinator 请求 permission</li><li>若资源被占用，可能 block，也可能返回错误消息</li></ul></li><li>缺点<ul><li>单点失效<ul><li>进程无法区分到底是 coordinator 失效了还是被 block 了</li></ul></li><li>性能瓶颈</li></ul></li></ul><h3 id="A-distributed-algorithm-P323-06-29"><a href="#A-distributed-algorithm-P323-06-29" class="headerlink" title="A distributed algorithm [P323] [06-29]"></a>A distributed algorithm [P323] [06-29]</h3><ul><li>方法<ul><li>基于 timestamp</li><li>请求资源的进程向所有进程请求 permission</li><li>若两个进程都感兴趣，timestamp 更早的胜出</li><li>获得所有进程的 permission 才可以使用资源、</li></ul></li><li>缺点<ul><li>单点失效（任何一个进程 fail 都会导致单点失效）</li><li>如果环境不支持广播，会很麻烦</li><li>相比集中式算法更慢、更复杂，还更易失效</li></ul></li></ul><h3 id="A-token-ring-algorithm-P325-06-32"><a href="#A-token-ring-algorithm-P325-06-32" class="headerlink" title="A token-ring algorithm [P325] [06-32]"></a>A token-ring algorithm [P325] [06-32]</h3><ul><li>方法<ul><li>在环上传递 token</li><li>拥有 token 的才能使用资源</li></ul></li><li>缺点<ul><li>token 丢失后很难判断</li></ul></li></ul><h3 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h3><p>见 [06-33]</p><h2 id="Election-选举机制-06-34"><a href="#Election-选举机制-06-34" class="headerlink" title="Election 选举机制 [06-34]"></a>Election 选举机制 [06-34]</h2><ul><li>ID 大的胜出</li><li>考虑进程 fail 的情况</li></ul><h3 id="The-bully-algorithm-P330-06-35"><a href="#The-bully-algorithm-P330-06-35" class="headerlink" title="The bully algorithm [P330] [06-35]"></a>The bully algorithm [P330] [06-35]</h3><ul><li>一个进程开始选举，发送 ELECTION 消息给 ID 更大的进程</li><li>进程收到 ELECTION 消息后，返回 OK 消息，并向更 ID 更大的进程发送 ELECTION 消息</li><li>收到 OK 消息的进程出局</li><li>如果发送 ELECTION 消息之后没有回应，当前进程成为 Leader</li></ul><h3 id="A-ring-algorithm-P332-06-38"><a href="#A-ring-algorithm-P332-06-38" class="headerlink" title="A ring algorithm [P332] [06-38]"></a>A ring algorithm [P332] [06-38]</h3><ul><li>一个进程开始选举，在环上发送 ELECTION 消息，跳过 fail 的进程</li><li>每个进程在环上添加自己的 ID，并继续传递</li><li>当 ELECTION 消息传了一圈后，选出 ID 最大的进程</li><li>发送 COORDINATOR 消息通知所有人谁是 Leader</li><li>如果两个进程同时开始选举，不影响时间复杂度，只是占用带宽增加</li></ul><h1 id="复制与一致性"><a href="#复制与一致性" class="headerlink" title="复制与一致性"></a>复制与一致性</h1><h2 id="复制的优势与不足-07-2"><a href="#复制的优势与不足-07-2" class="headerlink" title="复制的优势与不足 [07-2]"></a>复制的优势与不足 [07-2]</h2><ul><li>优势<ul><li>Reliability 可靠性<ul><li>避免单点失效</li></ul></li><li>Performance 性能<ul><li>服务器数量和地理区域上的可扩展性 scalability</li></ul></li></ul></li><li>劣势<ul><li>Replication transparency 复制透明性<ul><li>某个用户不知道某个对象是复制的</li></ul></li><li>一致性问题<ul><li>更新过程开销大</li><li>不小心可能影响系统可用性</li></ul></li></ul></li></ul><h2 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h2><ul><li>Data-centric consistency [07-9]<ul><li>未使用同步操作的模型<ul><li>Strict [07-10]<ul><li>最优解</li><li>不可能实现，隐含的假设存在绝对的全局时间</li></ul></li><li>Linearizability [07-12]</li><li>Sequential [07-11] [P364]<ul><li>所有的进程看到相同的操作序列</li><li>不一定按照时间先后</li></ul></li><li>Causal [07-14] [P368]<ul><li>有因果关系的写操作，不同的进程要看到相同的顺序</li><li>没有因果关系的写操作，不同的进程可以看到不同的顺序</li><li>比 Sequential consistency 要弱</li></ul></li><li>FIFO (PRAM) [07-17]<ul><li>由同一个进程进行的写操作，必须看到正确的顺序</li><li>由不同进程进行的写操作，不同进程可以看到不同的顺序</li></ul></li></ul></li><li>使用同步操作的模型<ul><li>Weak [07-21]<ul><li>完成一次同步后，共享数据一致</li></ul></li><li>Release [07-24]<ul><li>将同步操作分为Acquire和Release，是对Weak 的弱化</li><li>Acquire 的时候只需要本地的操作结束</li><li>Release 的时候将本地的更改传播到所有进程</li><li>离开一个临界区时，共享数据一致</li></ul></li><li>Entry [07-26] [P372]<ul><li>和 Release 模型类似</li><li>Acquire 的时候，所有对该变量的操作都要完成</li><li>进入共享数据对应临界区时，共享数据一致</li></ul></li></ul></li></ul></li><li>Client-centric consistency [07-29]<ul><li>Eventual [07-30] [P373]<ul><li>如果在一段相当长的时间内没有更新操作,那么所有的副本将逐渐成为一致的</li></ul></li><li>Monotonic reads [07-32] [P377]<ul><li>如果一个进程数据项 x 的值，那么该进程对 x 执行的任何后续读操作将总是得到第一次读取的那个值或更新的值</li><li>保证之后不会看到 x 的更老版本</li></ul></li><li>Monotonic writes [07-33] [P379]<ul><li>一个进程对数据项 x 执行的写操作必须在该进程对 x 执行任何后续写操作之前完成</li><li>写操作必须顺序完成，不能交叉</li></ul></li><li>Read your writes [07-34] [P380]<ul><li>一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见</li><li>保证读取总是最新的（一个进程内）</li></ul></li><li>Writes follow reads [07-35] [P382]<ul><li>同一个进程对数据项 x 执行的读操作之后的写操作，保证发生在与 x 读取值相同或比之更新的值上</li><li>更新是作为前一个读操作的结果传播的</li></ul></li></ul></li></ul><h2 id="数据一致性协议实例"><a href="#数据一致性协议实例" class="headerlink" title="数据一致性协议实例"></a>数据一致性协议实例</h2><h3 id="Quorum-based-protocols-基于法定数量的协议-P402-07-45"><a href="#Quorum-based-protocols-基于法定数量的协议-P402-07-45" class="headerlink" title="Quorum-based protocols 基于法定数量的协议 [P402] [07-45]"></a>Quorum-based protocols 基于法定数量的协议 [P402] [07-45]</h3><ul><li>对于一个具有 N 个副本的文件<ul><li>客户要读取时，必须组织一个服务器数量为 Nr 的读团体(read quorum)</li><li>客户要修改时，必须组织一个服务器数量为 Nw 的写团体(write quorum)</li></ul></li><li>其中，Nr 与 Nw 满足以下限制条件<ul><li>Nr+Nw&gt;N: 用于防止读写冲突</li><li>Nw&gt;N/2: 用于防止写写冲突</li></ul></li></ul><h1 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h1><h2 id="可信系统-dependable-systems-特征-08-3"><a href="#可信系统-dependable-systems-特征-08-3" class="headerlink" title="可信系统(dependable systems)特征 [08-3]"></a>可信系统(dependable systems)特征 [08-3]</h2><ul><li>Availability 可用性<ul><li>系统可以立即被使用</li><li>在给定时间点可以最大可能地正常工作</li></ul></li><li>Reliability 可靠性<ul><li>(在一段时间内)持续运行，而没有 failure</li></ul></li><li>Safety 安全性<ul><li>当系统暂时无法正常运行时，不会造成灾难性后果（例：核电站）</li></ul></li><li>Maintainability 可维护性<ul><li>系统 fail 后是否容易修复</li></ul></li></ul><p>一些概念（不在考点内）    ：</p><p>fault –&gt; error –&gt; failure</p><ul><li><strong>failure</strong>: 没有满足承诺，无法提供服务</li><li><strong>error</strong>: 系统的错误状态，可能导致 failure</li><li><strong>fault</strong>: 造成 error 的原因</li></ul><p>Failure 的分类</p><ul><li>Crash failure</li><li>Omission failure</li><li>Timing failure</li><li>Response failure</li><li>Byzantine failure</li></ul><h2 id="提高系统可信性-Dependability-的途径-08-9"><a href="#提高系统可信性-Dependability-的途径-08-9" class="headerlink" title="提高系统可信性(Dependability)的途径 [08-9]"></a>提高系统可信性(Dependability)的途径 [08-9]</h2><p>使用冗余来掩盖故障 (Mask failures by redundancy)</p><ul><li>Information redundancy<ul><li>在数据传输中添加纠错码</li></ul></li><li>Time redundancy<ul><li>事务处理终止，则重新执行</li></ul></li><li>Physical redundancy<ul><li>添加额外的机器或进程，使整体容忍部分错误</li></ul></li></ul><h2 id="k-容错系统"><a href="#k-容错系统" class="headerlink" title="k-容错系统"></a>k-容错系统</h2><p>k-容错定义 [P435]</p><ul><li>A system is said to be k-fault tolerant if it can survive faults in k components and still meet its specifications 系统能够经受 k 个组件的故障并且还能满足规范要求</li></ul><p>k-容错所需要的冗余数</p><ul><li>失败沉默 Fail-silent faults：K+1</li><li>拜占庭失败 Byzantine faults ：2K+1</li></ul><h2 id="拜占庭问题-Byzantine-agreement-problem"><a href="#拜占庭问题-Byzantine-agreement-problem" class="headerlink" title="拜占庭问题 (Byzantine agreement problem)"></a>拜占庭问题 (Byzantine agreement problem)</h2><p>算法步骤</p><ol><li>每个将军向其他 n-1 个将军告知自己的兵力（真实或说谎）</li><li>每个将军将收到的消息组成一个长度为 n 的向量</li><li>每个将军将自己的向量发送给其他 n-1 个将军</li><li>每个将军检查每个接收到的向量中的第 i 个元素，将其众数作为其结果向量的第 i 个元素</li></ol><h2 id="Distributed-commit-不在考点中"><a href="#Distributed-commit-不在考点中" class="headerlink" title="Distributed commit (不在考点中)"></a>Distributed commit (不在考点中)</h2><ul><li>Two-phase commit</li><li>Three-phase commit</li></ul><h2 id="系统恢复-08-54"><a href="#系统恢复-08-54" class="headerlink" title="系统恢复 [08-54]"></a>系统恢复 [08-54]</h2><p>真正发生故障以后，使崩溃的进程恢复到正确的状态。</p><h3 id="两种形式的错误恢复-08-55"><a href="#两种形式的错误恢复-08-55" class="headerlink" title="两种形式的错误恢复 [08-55]"></a>两种形式的错误恢复 [08-55]</h3><ul><li>回退恢复 (backward recovery)<ul><li>从当前的错误状态回退到先前的正确状态</li><li>定时记录系统的状态，称为<strong>检查点</strong></li></ul></li><li>前向恢复 (forward recovery)<ul><li>尝试从某点继续执行，把系统带入一个正确的新状态</li><li>关键在于必须预先知道会发生什么错误</li></ul></li></ul><h3 id="检查点-Checkpointing-08-56"><a href="#检查点-Checkpointing-08-56" class="headerlink" title="检查点(Checkpointing) [08-56]"></a>检查点(Checkpointing) [08-56]</h3><ul><li>独立检查点(Independent checkpointing) [08-58]<ul><li>每个进程独立地设置本地检查点</li><li>每个进程回退到的状态可能不一致，需要继续回退，可能造成多米诺效应</li></ul></li><li>协调检查点(Coordinated checkpointing) [08-59]<ul><li>所保存的状态自动保持全局一致</li><li>两个算法：<ul><li>Distributed snapshot algorithm</li><li>Two-phase blocking protocol</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式系统模型&quot;&gt;&lt;a href=&quot;#分布式系统模型&quot; class=&quot;headerlink&quot; title=&quot;分布式系统模型&quot;&gt;&lt;/a&gt;分布式系统模型&lt;/h1&gt;&lt;h2 id=&quot;什么是分布式系统-01-8&quot;&gt;&lt;a href=&quot;#什么是分布式系统-01-8&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式系统 [01-8]&quot;&gt;&lt;/a&gt;什么是分布式系统 [01-8]&lt;/h2&gt;&lt;p&gt;A distributed system is a collection of &lt;strong&gt;autonomous(自治的) computing elements&lt;/strong&gt; that appears to its users as a &lt;strong&gt;single coherent(一致的) system&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个计算单元(机器/进程)可以独立地工作（但他们通过通信相互协作）&lt;/li&gt;
&lt;li&gt;用户(人或应用)认为他面对的是一个单一系统（分布式透明性）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么要分布式-01-11&quot;&gt;&lt;a href=&quot;#为什么要分布式-01-11&quot; class=&quot;headerlink&quot; title=&quot;为什么要分布式? [01-11]&quot;&gt;&lt;/a&gt;为什么要分布式? [01-11]&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Economic: 微处理器比大型机性价比高&lt;/li&gt;
&lt;li&gt;Speed: 分布式系统整个计算能力比单个大型主机要强 ==&amp;gt; Performance&lt;/li&gt;
&lt;li&gt;Inherent(固有的) distribution: 有些应用涉及到空间上分散的机器&lt;/li&gt;
&lt;li&gt;Reliability: 如果其中一台机器崩溃,整体系统仍然能够运转 ==&amp;gt; Availability&lt;/li&gt;
&lt;li&gt;Incremental growth: 计算能力可以逐渐有所增加 ==&amp;gt; Scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分布式系统的目标-01-12&quot;&gt;&lt;a href=&quot;#分布式系统的目标-01-12&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的目标 [01-12]&quot;&gt;&lt;/a&gt;分布式系统的目标 [01-12]&lt;/h2&gt;&lt;p&gt;（构建分布式系统的时候应该努力达成的重要目标）&lt;/p&gt;
&lt;p&gt;“ATOS”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making resources &lt;strong&gt;available&lt;/strong&gt; 可用性&lt;ul&gt;
&lt;li&gt;用户易于访问, 易于共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transparency&lt;/strong&gt; 透明性: Hide the fact that resources are distributed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Openness&lt;/strong&gt; 开放性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt; 可扩展性&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;size scalability&lt;/strong&gt;: 可以容易地添加用户/资源，而没有显著的性能损失&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;geographical scalability&lt;/strong&gt;: 用户/资源可能距离很远，但没有显著的通信延迟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;administrative scalability&lt;/strong&gt;: An administratively scalable system is one that can still be easily managed even if it spans many independent administrative organizations. 即使跨越许多独立的行政组织，仍然可以轻松管理&lt;/li&gt;
&lt;li&gt;大部分系统可以做到第一点，但后两点很难做到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo 新主题 NexT</title>
    <link href="http://yoursite.com/posts/2017/New-Hexo-Theme-Next/"/>
    <id>http://yoursite.com/posts/2017/New-Hexo-Theme-Next/</id>
    <published>2017-12-01T13:52:26.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客从建立之处一直使用<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>主题。当时觉得它非常漂亮，但是不知道从哪天开始，yilia主题的代码高亮莫名其妙变成了黑色背景，而且总是出现滚动条。这种情况对于强迫症的我来说是不能忍的。这次我终于换上了新主题<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>。</p><p>NexT比当时yilia给我的感觉还要清爽简洁，同样支持标签页面的查看。NexT还多了一个功能是文章的目录结构。不过我发现我过去一些文章的目录结构显示混乱。排查之后，是因为使用Markdown标题不规范。如果一篇文章里只用了<code>&lt;h1&gt;</code>和<code>&lt;h3&gt;</code>，没用<code>&lt;h2&gt;</code>，就会导致NexT显示目录结构混乱，看来我以后写Markdown必须按规范的来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个博客从建立之处一直使用&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yilia&lt;/a&gt;主题。当时觉得它非常漂亮，但是不知道从哪天开始，yilia主题
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>编译Android源码时遇到的问题与解决方案</title>
    <link href="http://yoursite.com/posts/2017/Compiling-Android-Source-Code/"/>
    <id>http://yoursite.com/posts/2017/Compiling-Android-Source-Code/</id>
    <published>2017-09-07T15:03:22.000Z</published>
    <updated>2019-12-17T13:30:12.274Z</updated>
    
    <content type="html"><![CDATA[<p>因为科研需要，我最近在编译Android源码，其间遇到的一些问题记录下来，以备日后查阅。</p><h1 id="Android-6"><a href="#Android-6" class="headerlink" title="Android 6"></a>Android 6</h1><h2 id="Installing-OpenJDK-7"><a href="#Installing-OpenJDK-7" class="headerlink" title="Installing OpenJDK 7"></a>Installing OpenJDK 7</h2><p>AOSP only accepts OpenJDK 7 as compiling Java version. No HotSpot (Oracle JDK).</p><p><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=477645" target="_blank" rel="noopener">http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=477645</a></p><p>Install via PPA.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa  </span><br><span class="line">sudo apt-get update   </span><br><span class="line">sudo apt-get install openjdk-7-jre</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="bison-No-such-file-or-directory"><a href="#bison-No-such-file-or-directory" class="headerlink" title="bison: No such file or directory"></a>bison: No such file or directory</h2><p>Error message:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash: prebuilts/misc/linux-x86/bison/bison: No such file or directory</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install  g++-multilib gcc-multilib</span><br></pre></td></tr></table></figure><h2 id="Link-error"><a href="#Link-error" class="headerlink" title="Link error"></a>Link error</h2><p>Error message:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br><span class="line">build/core/host_shared_library_internal.mk:51: recipe for target &apos;out/host/linux-x86/obj/lib/libart.so&apos; failed</span><br></pre></td></tr></table></figure><p>解决方法：修改文件 <code>art/build/Android.common_build.mk</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/build/Android.common_build.mk b/build/Android.common_build.mk</span><br><span class="line">index b84154b..8cf41c0 100644</span><br><span class="line"><span class="comment">--- a/build/Android.common_build.mk</span></span><br><span class="line"><span class="comment">+++ b/build/Android.common_build.mk</span></span><br><span class="line">@@ -74,7 +74,7 @@ ART_TARGET_CFLAGS :=</span><br><span class="line"> ART_HOST_CLANG := false</span><br><span class="line"> ifneq ($(WITHOUT_HOST_CLANG),true)</span><br><span class="line">   # By default, host builds use clang for better warnings.</span><br><span class="line"><span class="deletion">-  ART_HOST_CLANG := true</span></span><br><span class="line"><span class="addition">+  ART_HOST_CLANG := false</span></span><br><span class="line"> endif</span><br></pre></td></tr></table></figure><p>另一种解决方法：修改文件 <code>art/build/Android.common_build.mk</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/build/Android.common_build.mk b/build/Android.common_build.mk</span><br><span class="line">index b84154b..187ede8 100644</span><br><span class="line"><span class="comment">--- a/build/Android.common_build.mk</span></span><br><span class="line"><span class="comment">+++ b/build/Android.common_build.mk</span></span><br><span class="line">@@ -72,7 +72,7 @@ ART_TARGET_CFLAGS :=</span><br><span class="line"></span><br><span class="line"> # Host.</span><br><span class="line"> ART_HOST_CLANG := false</span><br><span class="line"><span class="deletion">-ifneq ($(WITHOUT_HOST_CLANG),true)</span></span><br><span class="line"><span class="addition">+ifeq ($(WITHOUT_HOST_CLANG),false)</span></span><br><span class="line">   # By default, host builds use clang for better warnings.</span><br><span class="line">   ART_HOST_CLANG := true</span><br><span class="line"> endif</span><br></pre></td></tr></table></figure><p>来源：<a href="https://blog.csdn.net/cnliwy/article/details/52189349" target="_blank" rel="noopener">https://blog.csdn.net/cnliwy/article/details/52189349</a></p><h1 id="Android-7"><a href="#Android-7" class="headerlink" title="Android 7"></a>Android 7</h1><h2 id="OpenJDK-8"><a href="#OpenJDK-8" class="headerlink" title="OpenJDK 8"></a>OpenJDK 8</h2><p>删除 openjdk-7-jre，安装 openjdk-8-jre。</p><h2 id="Out-of-memory"><a href="#Out-of-memory" class="headerlink" title="Out of memory"></a>Out of memory</h2><p>Error message:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ 34% 12315/35670] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex</span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex.rsp</span><br><span class="line">Out of memory error (version 1.2-rc4 &apos;Carnac&apos; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)).</span><br><span class="line">GC overhead limit exceeded.</span><br><span class="line">Try increasing heap size with java option &apos;-Xmx&lt;size&gt;&apos;.</span><br><span class="line">Warning: This may have produced partial or corrupted output.</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build/core/ninja.mk:148: recipe for target &apos;ninja_wrapper&apos; failed</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git prebuilts/sdk/tools/jack-admin prebuilts/sdk/tools/jack-admin</span><br><span class="line">index ee193fc..3c9178a 100755</span><br><span class="line"><span class="comment">--- a/prebuilts/sdk/tools/jack-admin</span></span><br><span class="line"><span class="comment">+++ b/prebuilts/sdk/tools/jack-admin</span></span><br><span class="line">@@ -451,7 +451,7 @@ case $COMMAND in</span><br><span class="line">     if [ "$RUNNING" = 0 ]; then</span><br><span class="line">       echo "Server is already running"</span><br><span class="line">     else</span><br><span class="line"><span class="deletion">-      JACK_SERVER_COMMAND="java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME"</span></span><br><span class="line"><span class="addition">+      JACK_SERVER_COMMAND="java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx4096m -cp $LAUNCHER_JAR $LAUNCHER_NAME"</span></span><br><span class="line">       echo "Launching Jack server" $JACK_SERVER_COMMAND</span><br><span class="line">       (</span><br><span class="line">         trap "" SIGHUP</span><br></pre></td></tr></table></figure><p>重启jack-admin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prebuilts/sdk/tools/jack-admin stop-server</span><br><span class="line">./prebuilts/sdk/tools/jack-admin start-server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为科研需要，我最近在编译Android源码，其间遇到的一些问题记录下来，以备日后查阅。&lt;/p&gt;
&lt;h1 id=&quot;Android-6&quot;&gt;&lt;a href=&quot;#Android-6&quot; class=&quot;headerlink&quot; title=&quot;Android 6&quot;&gt;&lt;/a&gt;Android 6&lt;/h1&gt;&lt;h2 id=&quot;Installing-OpenJDK-7&quot;&gt;&lt;a href=&quot;#Installing-OpenJDK-7&quot; class=&quot;headerlink&quot; title=&quot;Installing OpenJDK 7&quot;&gt;&lt;/a&gt;Installing OpenJDK 7&lt;/h2&gt;&lt;p&gt;AOSP only accepts OpenJDK 7 as compiling Java version. No HotSpot (Oracle JDK).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;amp;t=477645&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;amp;t=477645&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Install via PPA.&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository ppa:openjdk-r/ppa  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install openjdk-7-jre&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>将Java Web项目从Myeclipse迁移到Maven</title>
    <link href="http://yoursite.com/posts/2016/Migrate-Java-Web-Project-From-Myeclipse-To-Maven/"/>
    <id>http://yoursite.com/posts/2016/Migrate-Java-Web-Project-From-Myeclipse-To-Maven/</id>
    <published>2016-11-06T13:34:56.000Z</published>
    <updated>2019-12-17T13:30:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>一年前和<a href="https://github.com/checkyh" target="_blank" rel="noopener">checky</a>同学合作写了一个Java Web项目<a href="https://github.com/nettee/IFTTT-Web" target="_blank" rel="noopener">IFTTT-Web</a>。当时这个项目是作为课程的编程作业，为了尽快完成项目，我们选择在MyEclipse中进行开发。课程结束之后代码就一直搁置，有一天我想在Eclipse中重新配置项目（MyEclipse是收费软件，我的电脑里已经不再安装），但没有成功。Java Web项目比较复杂，除了Java代码之外，还包括JSP页面、JavaScript脚本、CSS文件等各种webapp需要的文件，想把一个已有的项目重新在Eclipse里运行起来，确实比较困难。</p><p>我当时尝试了一种更为“原始”的做法：在命令行下手工编译Java源文件，将编译后的字节码和webapp文件拷贝到Tomcat的目录下。这种方法当然成功了，但部署需要的手工操作太多，显然不是长久之计。直到不久之前，我才了解到Maven这个工具在Java世界里的重要地位，并开始在我的项目里使用Maven。这次我尝试用Maven重新构建一年前的项目，终于成功，在这里记录一下全部的过程。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>生成Maven webapp项目骨架</li><li>更改目录结构</li><li>添加依赖</li><li>使用jetty</li></ol><a id="more"></a><h2 id="生成Maven-webapp项目骨架"><a href="#生成Maven-webapp项目骨架" class="headerlink" title="生成Maven webapp项目骨架"></a>生成Maven webapp项目骨架</h2><p>为了清晰直观，这里我先生成Maven webapp的目录骨架，再把已有的文件搬到对应的目录里。运行<code>mvn archetype:generate</code>，注意artifactId选择org.apache.maven.archetypes:maven-archetype-webapp。</p><h2 id="更改目录结构"><a href="#更改目录结构" class="headerlink" title="更改目录结构"></a>更改目录结构</h2><p>首先让我们看一下<a href="https://github.com/nettee/IFTTT-Web/tree/629f50ed92b755294b29ab90f79604700d4739e8" target="_blank" rel="noopener">更新之前的目录结构</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── log4j.properties</span><br><span class="line">│   ├── database</span><br><span class="line">│   ├── model</span><br><span class="line">│   │   ├── data</span><br><span class="line">│   │   └── task</span><br><span class="line">│   ├── servlet</span><br><span class="line">│   └── task</span><br><span class="line">│       ├── action</span><br><span class="line">│       ├── mail</span><br><span class="line">│       ├── run</span><br><span class="line">│       ├── trigger</span><br><span class="line">│       └── weibo</span><br><span class="line">│── weibo</span><br><span class="line">│   ├── config.properties</span><br><span class="line">│   ├── log4j.properties</span><br><span class="line">│   └── weibo4j</span><br><span class="line">│       └── ...</span><br><span class="line">├── lib</span><br><span class="line">│   └── ...</span><br><span class="line">└── WebRoot</span><br><span class="line">    ├── assets</span><br><span class="line">    ├── component</span><br><span class="line">    ├── css</span><br><span class="line">    ├── dashboard.jsp</span><br><span class="line">    ├── favicon.ico</span><br><span class="line">    ├── font</span><br><span class="line">    ├── index.jsp</span><br><span class="line">    ├── js</span><br><span class="line">    ├── login.jsp</span><br><span class="line">    ├── META-INF</span><br><span class="line">    │   └── MANIFEST.MF</span><br><span class="line">    ├── register.jsp</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure><p>这是一个典型的MyEclipse生成的Java Web项目的目录结构，WebRoot目录下放着webapp需要的各种文件。需要注意的是，src和weibo都是source folder。</p><p>而上一步生成的Maven项目骨架是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        ├── resources</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── index.jsp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                └── web.xml</span><br></pre></td></tr></table></figure><p>按照Maven对webapp项目的约定，src/main/java放置Java源代码，src/main/resources放置资源文件，src/main/webapp放置JSP、JavaScript、CSS等文件，其中web.xml放置在src/main/webapp/WEB-INF目录下。</p><p>那么，原来的文件这样进行移动：</p><ol><li>src、weibo目录下所有包含Java源代码的子目录移动到src/main/java目录中</li><li>配置文件config.properties，log4j.properties移动到src/main/resources目录中</li><li>WebRoot目录下所有的文件原样移动到src/main/webapp中</li></ol><p>感觉移动起来还是挺简单的:) 原来的lib目录就不需要了，我们马上会使用Maven依赖来完成这个任务。文件移动之后的目录结构可以参看<a href="https://github.com/nettee/IFTTT-Web/tree/b4af1ab6926b20cf8d6a557d47216513260c4356" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   ├── database</span><br><span class="line">    │   │   ├── model</span><br><span class="line">    │   │   │   ├── data</span><br><span class="line">    │   │   │   └── task</span><br><span class="line">    │   │   ├── servlet</span><br><span class="line">    │   │   ├── task</span><br><span class="line">    │   │   │   ├── action</span><br><span class="line">    │   │   │   ├── mail</span><br><span class="line">    │   │   │   ├── run</span><br><span class="line">    │   │   │   ├── trigger</span><br><span class="line">    │   │   │   └── weibo</span><br><span class="line">    │   │   └── weibo4j</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   │   ├── config.properties</span><br><span class="line">    │   │   ├── log4j.properties</span><br><span class="line">    │   │   └── schema.sql</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       ├── assets</span><br><span class="line">    │       ├── component</span><br><span class="line">    │       ├── css</span><br><span class="line">    │       ├── dashboard.jsp</span><br><span class="line">    │       ├── favicon.ico</span><br><span class="line">    │       ├── font</span><br><span class="line">    │       ├── index.jsp</span><br><span class="line">    │       ├── js</span><br><span class="line">    │       ├── login.jsp</span><br><span class="line">    │       ├── META-INF</span><br><span class="line">    │       │   └── MANIFEST.MF</span><br><span class="line">    │       ├── register.jsp</span><br><span class="line">    │       └── WEB-INF</span><br><span class="line">    │           └── web.xml</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br></pre></td></tr></table></figure><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>pom.xml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.mail&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mail&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-httpclient&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用jetty"><a href="#使用jetty" class="headerlink" title="使用jetty"></a>使用jetty</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>9.2.11.v20150529<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webApp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webApp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jetty:run</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年前和&lt;a href=&quot;https://github.com/checkyh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;checky&lt;/a&gt;同学合作写了一个Java Web项目&lt;a href=&quot;https://github.com/nettee/IFTTT-Web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IFTTT-Web&lt;/a&gt;。当时这个项目是作为课程的编程作业，为了尽快完成项目，我们选择在MyEclipse中进行开发。课程结束之后代码就一直搁置，有一天我想在Eclipse中重新配置项目（MyEclipse是收费软件，我的电脑里已经不再安装），但没有成功。Java Web项目比较复杂，除了Java代码之外，还包括JSP页面、JavaScript脚本、CSS文件等各种webapp需要的文件，想把一个已有的项目重新在Eclipse里运行起来，确实比较困难。&lt;/p&gt;
&lt;p&gt;我当时尝试了一种更为“原始”的做法：在命令行下手工编译Java源文件，将编译后的字节码和webapp文件拷贝到Tomcat的目录下。这种方法当然成功了，但部署需要的手工操作太多，显然不是长久之计。直到不久之前，我才了解到Maven这个工具在Java世界里的重要地位，并开始在我的项目里使用Maven。这次我尝试用Maven重新构建一年前的项目，终于成功，在这里记录一下全部的过程。&lt;/p&gt;
&lt;h2 id=&quot;主要步骤&quot;&gt;&lt;a href=&quot;#主要步骤&quot; class=&quot;headerlink&quot; title=&quot;主要步骤&quot;&gt;&lt;/a&gt;主要步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;生成Maven webapp项目骨架&lt;/li&gt;
&lt;li&gt;更改目录结构&lt;/li&gt;
&lt;li&gt;添加依赖&lt;/li&gt;
&lt;li&gt;使用jetty&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JSP" scheme="http://yoursite.com/tags/JSP/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
</feed>
